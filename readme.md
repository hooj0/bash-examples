+ [/.idea/inspectionProfiles](.//.idea/inspectionProfiles)
+ [/.idea](.//.idea)
+ [/01_example_started](.//01_example_started)
	- [hello_world.sh](.//01_example_started/hello_world.sh)
		+ [运行 Shell 脚本有两种方法：#L11](.//01_example_started/hello_world.sh#L11)
		+ [1、作为可执行程序#L14](.//01_example_started/hello_world.sh#L14)
		+ [将上面的代码保存为 hello_world.sh，并 cd 到相应目录：#L16](.//01_example_started/hello_world.sh#L16)
		+ [#L17](.//01_example_started/hello_world.sh#L17)
		+ [chmod +x ./hello_world.sh  使脚本具有执行权限#L18](.//01_example_started/hello_world.sh#L18)
		+ [./hello_world.sh  执行脚本#L19](.//01_example_started/hello_world.sh#L19)
		+ [#L20](.//01_example_started/hello_world.sh#L20)
		+ [注意，一定要写成 ./hello_world.sh，而不是 hello_world.sh，运行其它二进制的程序也一样，#L22](.//01_example_started/hello_world.sh#L22)
		+ [直接写 hello_world.sh，linux 系统会去 PATH 里寻找有没有叫 hello_world.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，#L23](.//01_example_started/hello_world.sh#L23)
		+ [你的当前目录通常不在 PATH 里，所以写成 hello_world.sh 是会找不到命令的，要用 ./hello_world.sh 告诉系统说，就在当前目录找。#L24](.//01_example_started/hello_world.sh#L24)
		+ [2、作为解释器参数#L28](.//01_example_started/hello_world.sh#L28)
		+ [这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：#L30](.//01_example_started/hello_world.sh#L30)
		+ [/bin/sh hello_world.sh#L32](.//01_example_started/hello_world.sh#L32)
		+ [/bin/php hello_world.php#L33](.//01_example_started/hello_world.sh#L33)
		+ [sh hello_world.sh#L35](.//01_example_started/hello_world.sh#L35)
		+ [bash hello_world.sh#L36](.//01_example_started/hello_world.sh#L36)
		+ [这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。#L38](.//01_example_started/hello_world.sh#L38)
		+ [source、sh、bash、./ 执行脚本的区别是什么？#L45](.//01_example_started/hello_world.sh#L45)
		+ [1. source命令用法：#L49](.//01_example_started/hello_world.sh#L49)
		+ [source FileName#L51](.//01_example_started/hello_world.sh#L51)
		+ [作用:在当前 bash 环境下读取并执行 FileName 中的命令。该 filename 文件可以无 "执行权限"。#L52](.//01_example_started/hello_world.sh#L52)
		+ [注：该命令通常用命令 . 来替代。#L54](.//01_example_started/hello_world.sh#L54)
		+ [2. sh、bash的命令用法：#L57](.//01_example_started/hello_world.sh#L57)
		+ [sh FileName#L59](.//01_example_started/hello_world.sh#L59)
		+ [或#L60](.//01_example_started/hello_world.sh#L60)
		+ [bash FileName#L61](.//01_example_started/hello_world.sh#L61)
		+ [作用:打开一个子 shell 来读取并执行 FileName 中命令。该 filename 文件可以无 "执行权限"。#L63](.//01_example_started/hello_world.sh#L63)
		+ [注：运行一个shell脚本时会启动另一个命令解释器。#L64](.//01_example_started/hello_world.sh#L64)
		+ [3、./的命令用法：#L67](.//01_example_started/hello_world.sh#L67)
		+ [./FileName#L69](.//01_example_started/hello_world.sh#L69)
		+ [作用: 打开一个子 shell 来读取并执行 FileName 中命令，该 filename 文件需要 "执行权限"。#L70](.//01_example_started/hello_world.sh#L70)
		+ [注：运行一个 shell 脚本时会启动另一个命令解释器。#L72](.//01_example_started/hello_world.sh#L72)
+ [/02_examples_variable](.//02_examples_variable)
	- [var_assignment.sh](.//02_examples_variable/var_assignment.sh)
		+ [变量运算赋值#L25](.//02_examples_variable/var_assignment.sh#L25)
		+ [bash 里面可以用 (( )) 执行 C 风格的算术表达式#L27](.//02_examples_variable/var_assignment.sh#L27)
		+ [$(( )) 会展开成为这个 C 表达式求值的结果。以前 bash 有个 $[ ] 一样，但是别去用。#L45](.//02_examples_variable/var_assignment.sh#L45)
		+ [变量参数默认值#L56](.//02_examples_variable/var_assignment.sh#L56)
		+ [${name:?参数不存在}#L58](.//02_examples_variable/var_assignment.sh#L58)
		+ [echo "${name:-haha}"#L59](.//02_examples_variable/var_assignment.sh#L59)
		+ [当文件执行参数不为1个时，提示#L62](.//02_examples_variable/var_assignment.sh#L62)
		+ [input_file=${1:?用法: $0 args}#L63](.//02_examples_variable/var_assignment.sh#L63)
		+ [echo "$input_file"#L64](.//02_examples_variable/var_assignment.sh#L64)
		+ [当文件参数有2个时#L67](.//02_examples_variable/var_assignment.sh#L67)
		+ [output_file=${2:-logfile}#L68](.//02_examples_variable/var_assignment.sh#L68)
		+ [echo "$output_file"#L69](.//02_examples_variable/var_assignment.sh#L69)
		+ [变量$foo尚未设置。在严格模式下，下一行触发错误。#L73](.//02_examples_variable/var_assignment.sh#L73)
		+ [${VARNAME:-DEFAULT_VALUE} 如果 VARNAME 未定义，则使用 DEFAULT_VALUE 作为默认值.#L76](.//02_examples_variable/var_assignment.sh#L76)
		+ [So here, $bar is set to "alpha":#L77](.//02_examples_variable/var_assignment.sh#L77)
		+ [现在我们明确地设置foo：#L80](.//02_examples_variable/var_assignment.sh#L80)
		+ [忽略默认值. $bar = "beta":#L83](.//02_examples_variable/var_assignment.sh#L83)
		+ [要使默认值为空字符串，请使用 ${VARNAME:-}#L86](.//02_examples_variable/var_assignment.sh#L86)
	- [var_declare.sh](.//02_examples_variable/var_declare.sh)
		+ [var$temp="st1"  var=st1: 未找到命令#L10](.//02_examples_variable/var_declare.sh#L10)
		+ [#L12](.//02_examples_variable/var_declare.sh#L12)
		+ [变量名的命名须遵循如下规则：#L13](.//02_examples_variable/var_declare.sh#L13)
		+ [*、变量名和等号之间不能有空格#L14](.//02_examples_variable/var_declare.sh#L14)
		+ [1、命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。#L15](.//02_examples_variable/var_declare.sh#L15)
		+ [2、中间不能有空格，可以使用下划线（_）。#L16](.//02_examples_variable/var_declare.sh#L16)
		+ [3、不能使用标点符号。#L17](.//02_examples_variable/var_declare.sh#L17)
		+ [4、不能使用bash里的关键字（可用help命令查看保留关键字）。#L18](.//02_examples_variable/var_declare.sh#L18)
		+ [help#L20](.//02_examples_variable/var_declare.sh#L20)
		+ [var1 = "不能有空格"	 var1: 未找到命令#L22](.//02_examples_variable/var_declare.sh#L22)
		+ [有效的 Shell 变量名示例如下：#L30](.//02_examples_variable/var_declare.sh#L30)
		+ [无效的变量命名：#L37](.//02_examples_variable/var_declare.sh#L37)
		+ [?var=123#L38](.//02_examples_variable/var_declare.sh#L38)
		+ [user*name=runoob#L39](.//02_examples_variable/var_declare.sh#L39)
		+ [#L43](.//02_examples_variable/var_declare.sh#L43)
		+ [除了显式地直接赋值，还可以用语句给变量赋值，如：#L44](.//02_examples_variable/var_declare.sh#L44)
		+ [将 /etc 下目录的文件名循环出来。#L46](.//02_examples_variable/var_declare.sh#L46)
		+ [或#L51](.//02_examples_variable/var_declare.sh#L51)
	- [var_delete.sh](.//02_examples_variable/var_delete.sh)
		+ [unset variable_name#L9](.//02_examples_variable/var_delete.sh#L9)
		+ [#L10](.//02_examples_variable/var_delete.sh#L10)
		+ [变量被删除后不能再次使用。#L11](.//02_examples_variable/var_delete.sh#L11)
		+ [unset 命令不能删除只读变量。#L12](.//02_examples_variable/var_delete.sh#L12)
		+ [#L13](.//02_examples_variable/var_delete.sh#L13)
		+ [实例#L17](.//02_examples_variable/var_delete.sh#L17)
		+ [以上实例执行将没有任何输出。#L23](.//02_examples_variable/var_delete.sh#L23)
	- [var_readonly.sh](.//02_examples_variable/var_readonly.sh)
		+ [设置为只读#L9](.//02_examples_variable/var_readonly.sh#L9)
		+ [下面的例子尝试更改只读变量，结果报错：#L12](.//02_examples_variable/var_readonly.sh#L12)
		+ [运行脚本，结果如下：#L15](.//02_examples_variable/var_readonly.sh#L15)
		+ [/bin/sh: NAME: This variable is read only.#L16](.//02_examples_variable/var_readonly.sh#L16)
	- [var_scope.sh](.//02_examples_variable/var_scope.sh)
		+ [1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。#L9](.//02_examples_variable/var_scope.sh#L9)
		+ [2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。#L10](.//02_examples_variable/var_scope.sh#L10)
		+ [3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行#L11](.//02_examples_variable/var_scope.sh#L11)
	- [var_ternary_op.sh](.//02_examples_variable/var_ternary_op.sh)
	- [var_used.sh](.//02_examples_variable/var_used.sh)
		+ [使用一个定义过的变量，只要在变量名前面加美元符号即可，如：#L9](.//02_examples_variable/var_used.sh#L9)
		+ [变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：#L15](.//02_examples_variable/var_used.sh#L15)
		+ [如果不给skill变量加花括号，写成echo "I am good at $skillScript"，#L20](.//02_examples_variable/var_used.sh#L20)
		+ [解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。#L21](.//02_examples_variable/var_used.sh#L21)
		+ [推荐给所有变量加上花括号，这是个好的编程习惯。#L23](.//02_examples_variable/var_used.sh#L23)
		+ [已定义的变量，可以被重新定义，如：#L25](.//02_examples_variable/var_used.sh#L25)
		+ [这样写是合法的，但注意，第二次赋值的时候不能写$your_name="alibaba"，使用变量的时候才加美元符（$）。#L31](.//02_examples_variable/var_used.sh#L31)
+ [/03_examples_data_type](.//03_examples_data_type)
	- [type_arrays.sh](.//03_examples_data_type/type_arrays.sh)
		+ [类似与C语言，数组元素的下标由0开始编号。#L9](.//03_examples_data_type/type_arrays.sh#L9)
		+ [获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。#L10](.//03_examples_data_type/type_arrays.sh#L10)
		+ [#L11](.//03_examples_data_type/type_arrays.sh#L11)
		+ [定义数组#L13](.//03_examples_data_type/type_arrays.sh#L13)
		+ [在Shell中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为：#L15](.//03_examples_data_type/type_arrays.sh#L15)
		+ [#L16](.//03_examples_data_type/type_arrays.sh#L16)
		+ [数组名=(值1 值2 ... 值n)#L17](.//03_examples_data_type/type_arrays.sh#L17)
		+ [例如：#L21](.//03_examples_data_type/type_arrays.sh#L21)
		+ [或者#L26](.//03_examples_data_type/type_arrays.sh#L26)
		+ [或者#L35](.//03_examples_data_type/type_arrays.sh#L35)
		+ [还可以单独定义数组的各个分量：#L39](.//03_examples_data_type/type_arrays.sh#L39)
		+ [可以不使用连续的下标，而且下标的范围没有限制。#L41](.//03_examples_data_type/type_arrays.sh#L41)
		+ [a 会转换为 0#L55](.//03_examples_data_type/type_arrays.sh#L55)
		+ [数组的值也可以写入变量。#L62](.//03_examples_data_type/type_arrays.sh#L62)
		+ [例如：#L65](.//03_examples_data_type/type_arrays.sh#L65)
		+ [读取数组#L76](.//03_examples_data_type/type_arrays.sh#L76)
		+ [读取数组元素值的一般格式是：#L78](.//03_examples_data_type/type_arrays.sh#L78)
		+ [${数组名[下标]}#L79](.//03_examples_data_type/type_arrays.sh#L79)
		+ [#L80](.//03_examples_data_type/type_arrays.sh#L80)
		+ [例如：#L81](.//03_examples_data_type/type_arrays.sh#L81)
		+ [使用@符号可以获取数组中的所有元素，例如：#L85](.//03_examples_data_type/type_arrays.sh#L85)
		+ [根据数组元素索引获取该数组元素值时，数组下标可为变量。#L89](.//03_examples_data_type/type_arrays.sh#L89)
		+ [获取数组的长度#L96](.//03_examples_data_type/type_arrays.sh#L96)
		+ [获取数组长度的方法与获取字符串长度的方法相同，例如：#L98](.//03_examples_data_type/type_arrays.sh#L98)
		+ [#L99](.//03_examples_data_type/type_arrays.sh#L99)
		+ [取得数组元素的个数#L100](.//03_examples_data_type/type_arrays.sh#L100)
		+ [或者#L104](.//03_examples_data_type/type_arrays.sh#L104)
		+ [取得数组单个元素的长度#L108](.//03_examples_data_type/type_arrays.sh#L108)
	- [type_strings.sh](.//03_examples_data_type/type_strings.sh)
		+ [单引号字符串的限制：#L9](.//03_examples_data_type/type_strings.sh#L9)
		+ [#L10](.//03_examples_data_type/type_strings.sh#L10)
		+ [单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；#L11](.//03_examples_data_type/type_strings.sh#L11)
		+ [单引号字串中不能出现单引号（对单引号使用转义符也不行）。#L12](.//03_examples_data_type/type_strings.sh#L12)
		+ [双引号的优点：#L14](.//03_examples_data_type/type_strings.sh#L14)
		+ [#L15](.//03_examples_data_type/type_strings.sh#L15)
		+ [双引号里可以有变量#L16](.//03_examples_data_type/type_strings.sh#L16)
		+ [双引号里可以出现转义字符#L17](.//03_examples_data_type/type_strings.sh#L17)
		+ [单引号#L21](.//03_examples_data_type/type_strings.sh#L21)
		+ [原样输出，表达式和转义字符无效#L26](.//03_examples_data_type/type_strings.sh#L26)
		+ [双引号#L31](.//03_examples_data_type/type_strings.sh#L31)
		+ [拼接字符串#L37](.//03_examples_data_type/type_strings.sh#L37)
		+ [获取字符串长度#L45](.//03_examples_data_type/type_strings.sh#L45)
		+ [提取子字符串#L53](.//03_examples_data_type/type_strings.sh#L53)
		+ [以下实例从字符串第 2 个字符开始截取 4 个字符：#L55](.//03_examples_data_type/type_strings.sh#L55)
		+ [查找子字符串#L59](.//03_examples_data_type/type_strings.sh#L59)
		+ [查找字符 "i 或 s" 的位置：#L61](.//03_examples_data_type/type_strings.sh#L61)
		+ [注意： 以上脚本中 "`" 是反引号，而不是单引号 "'"#L65](.//03_examples_data_type/type_strings.sh#L65)
		+ [字符串自动组合#L69](.//03_examples_data_type/type_strings.sh#L69)
	- [type_strings_substr.sh](.//03_examples_data_type/type_strings_substr.sh)
		+ [一个  表示从左边删除到第一个指定的字符；#L10](.//03_examples_data_type/type_strings_substr.sh#L10)
		+ [两个  表示从左边删除到最后一个指定的字符。#L11](.//03_examples_data_type/type_strings_substr.sh#L11)
		+ [%、%% 表示从右边开始删除。#L14](.//03_examples_data_type/type_strings_substr.sh#L14)
		+ [一个 % 表示从右边删除到第一个指定的字符；#L16](.//03_examples_data_type/type_strings_substr.sh#L16)
		+ [两个 % 表示从左边删除到最后一个指定的字符。#L17](.//03_examples_data_type/type_strings_substr.sh#L17)
		+ [删除包括了指定的字符本身。#L19](.//03_examples_data_type/type_strings_substr.sh#L19)
		+ [假设有变量#L22](.//03_examples_data_type/type_strings_substr.sh#L22)
		+ [1.  号截取，删除左边字符(第一个字符开始)，保留右边字符。#L27](.//03_examples_data_type/type_strings_substr.sh#L27)
		+ [其中 var 是变量名， 号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符#L29](.//03_examples_data_type/type_strings_substr.sh#L29)
		+ [2.  号截取，删除左边字符（最后一个字符开始），保留右边字符。#L35](.//03_examples_data_type/type_strings_substr.sh#L35)
		+ [*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符#L37](.//03_examples_data_type/type_strings_substr.sh#L37)
		+ [3. %号截取，删除右边字符，保留左边字符#L44](.//03_examples_data_type/type_strings_substr.sh#L44)
		+ [%/* 表示从右边开始，删除第一个 / 号及右边的字符#L46](.//03_examples_data_type/type_strings_substr.sh#L46)
		+ [4. %% 号截取，删除右边字符，保留左边字符#L52](.//03_examples_data_type/type_strings_substr.sh#L52)
		+ [%%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符#L54](.//03_examples_data_type/type_strings_substr.sh#L54)
		+ [5. 从左边第几个字符开始，及字符的个数#L60](.//03_examples_data_type/type_strings_substr.sh#L60)
		+ [其中的 0 表示左边第一个字符开始，5 表示字符的总个数。#L62](.//03_examples_data_type/type_strings_substr.sh#L62)
		+ [6. 从左边第几个字符开始，一直到结束。#L68](.//03_examples_data_type/type_strings_substr.sh#L68)
		+ [其中的 7 表示左边第8个字符开始，一直到结束。#L70](.//03_examples_data_type/type_strings_substr.sh#L70)
		+ [7. 从右边第几个字符开始，及字符的个数#L76](.//03_examples_data_type/type_strings_substr.sh#L76)
		+ [其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数。#L78](.//03_examples_data_type/type_strings_substr.sh#L78)
		+ [8. 从右边第几个字符开始，一直到结束。#L84](.//03_examples_data_type/type_strings_substr.sh#L84)
		+ [表示从右边第七个字符开始，一直到结束。#L86](.//03_examples_data_type/type_strings_substr.sh#L86)
		+ [注：（左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示）#L87](.//03_examples_data_type/type_strings_substr.sh#L87)
		+ [实例演示#L94](.//03_examples_data_type/type_strings_substr.sh#L94)
		+ [运行结果：#L113](.//03_examples_data_type/type_strings_substr.sh#L113)
		+ [原字符串为：http://www.hoojo.com/linux/linux-shell-variable.html#L115](.//03_examples_data_type/type_strings_substr.sh#L115)
		+ [%%t*的效果：h#L116](.//03_examples_data_type/type_strings_substr.sh#L116)
		+ [%t*的效果：http://www.hoojo.com/linux/linux-shell-variable.h#L117](.//03_examples_data_type/type_strings_substr.sh#L117)
		+ [%%.*的效果：http://www#L118](.//03_examples_data_type/type_strings_substr.sh#L118)
		+ [*/的效果：/www.hoojo.com/linux/linux-shell-variable.html#L119](.//03_examples_data_type/type_strings_substr.sh#L119)
		+ [*/的效果：linux-shell-variable.html#L120](.//03_examples_data_type/type_strings_substr.sh#L120)
+ [/04_examples_args](.//04_examples_args)
	- [args_file.sh](.//04_examples_args/args_file.sh)
		+ [脚本文件选项参数的遍历与使用#L12](.//04_examples_args/args_file.sh#L12)
		+ [在使用脚本执行的时候，有时候需要传入动态参数调整脚本的运行流程。#L14](.//04_examples_args/args_file.sh#L14)
		+ [通过遍历参数列表，判断参数的选择和值，来进入不同的流程。#L15](.//04_examples_args/args_file.sh#L15)
		+ [示例：遍历参数列表，根据不同的选项执行不同的流程#L22](.//04_examples_args/args_file.sh#L22)
		+ [只有当第一个参数，带有 -- 或 - 的选项参数时，才进入循环#L26](.//04_examples_args/args_file.sh#L26)
		+ [output:#L47](.//04_examples_args/args_file.sh#L47)
		+ [$ ./args_file.sh -D hello -D world -A hoojo -s 123#L49](.//04_examples_args/args_file.sh#L49)
		+ [传入参数：-D hello -D world -A hoojo -s 123#L50](.//04_examples_args/args_file.sh#L50)
		+ [第一个参数：D#L51](.//04_examples_args/args_file.sh#L51)
		+ [该选项的参数就是hello#L52](.//04_examples_args/args_file.sh#L52)
		+ [该选项的参数就是world#L53](.//04_examples_args/args_file.sh#L53)
		+ [该选项的参数就是hoojo#L54](.//04_examples_args/args_file.sh#L54)
		+ [使用该脚本时，虽然使用了选项，但是脚本不支持的，都匹配 *#L55](.//04_examples_args/args_file.sh#L55)
		+ [在这里就可以提示用户：脚本的使用方法，如：usage | help#L56](.//04_examples_args/args_file.sh#L56)
		+ [示例：使用if来执行不同的流程分支#L62](.//04_examples_args/args_file.sh#L62)
		+ [output:#L87](.//04_examples_args/args_file.sh#L87)
		+ [合法的Options选项参数：-D#L89](.//04_examples_args/args_file.sh#L89)
		+ [description 选项-D的参数: test example#L90](.//04_examples_args/args_file.sh#L90)
		+ [author 选项--author的参数: hoojo#L91](.//04_examples_args/args_file.sh#L91)
		+ [没有匹配的流程：-S 123#L92](.//04_examples_args/args_file.sh#L92)
		+ [示例：bash shell 提供 shift 命令来帮助操作命令行参数，#L98](.//04_examples_args/args_file.sh#L98)
		+ [该命令能够改变命令行参数的相对位置。#L99](.//04_examples_args/args_file.sh#L99)
		+ [shift 默认将每个参数变量左移一个位置。#L100](.//04_examples_args/args_file.sh#L100)
		+ [如：假如给脚本或函数传递了2个参数，每执行一次shift命令，#L102](.//04_examples_args/args_file.sh#L102)
		+ [变量$2的值移组变量$1，变量$1的值被丢弃。#L103](.//04_examples_args/args_file.sh#L103)
		+ [#L104](.//04_examples_args/args_file.sh#L104)
		+ [shift 命令的使用#L105](.//04_examples_args/args_file.sh#L105)
		+ [shift [n]          设置步长。默认是为1 .#L106](.//04_examples_args/args_file.sh#L106)
		+ [调用函数#L123](.//04_examples_args/args_file.sh#L123)
		+ [output:#L125](.//04_examples_args/args_file.sh#L125)
		+ [参数列表：a b c d e f#L127](.//04_examples_args/args_file.sh#L127)
		+ [第1个参数：a#L128](.//04_examples_args/args_file.sh#L128)
		+ [第2个参数：b#L129](.//04_examples_args/args_file.sh#L129)
		+ [调用shift 2后……#L132](.//04_examples_args/args_file.sh#L132)
		+ [参数列表：c d e f 		 每调用shift 2 参数列表的前面的两个参数  被弹出移除#L133](.//04_examples_args/args_file.sh#L133)
		+ [第1个参数：c#L134](.//04_examples_args/args_file.sh#L134)
		+ [第2个参数：d#L135](.//04_examples_args/args_file.sh#L135)
		+ [示例：參數的檢查與使用#L141](.//04_examples_args/args_file.sh#L141)
		+ [checkArgs#L158](.//04_examples_args/args_file.sh#L158)
		+ [output:#L159](.//04_examples_args/args_file.sh#L159)
		+ [沒有參數選項，请输入合法的参数#L161](.//04_examples_args/args_file.sh#L161)
		+ [checkArgs a b c d#L163](.//04_examples_args/args_file.sh#L163)
		+ [output:#L164](.//04_examples_args/args_file.sh#L164)
		+ [文件脚本： ./args_file.sh#L166](.//04_examples_args/args_file.sh#L166)
		+ [参数列表:#L167](.//04_examples_args/args_file.sh#L167)
		+ [a#L168](.//04_examples_args/args_file.sh#L168)
		+ [b#L169](.//04_examples_args/args_file.sh#L169)
		+ [c#L170](.//04_examples_args/args_file.sh#L170)
		+ [d#L171](.//04_examples_args/args_file.sh#L171)
		+ [示例：getopt & getopts 获取参数选项列表#L177](.//04_examples_args/args_file.sh#L177)
		+ [getopts （shell内置命令）#L179](.//04_examples_args/args_file.sh#L179)
		+ [处理命令行参数是一个相似而又复杂的事情，为此，c提供了getopt/getopt_long等函数，#L180](.//04_examples_args/args_file.sh#L180)
		+ [c++的boost提供了options库，在shell中，处理此事的是getopts和getopt。#L181](.//04_examples_args/args_file.sh#L181)
		+ [getopts/getopt的区别，getopt是个外部binary文件，而getopts是shell builtin。#L183](.//04_examples_args/args_file.sh#L183)
		+ [getopts不能直接处理长的选项（如：--prefix=/home等）#L185](.//04_examples_args/args_file.sh#L185)
		+ [getopts有两个参数，第一个参数是一个字符串，包括字符和“：”，#L187](.//04_examples_args/args_file.sh#L187)
		+ [每一个字符都是一个有效的选项，如果字符后面带有“：”，表示这个字符有自己的参数。#L188](.//04_examples_args/args_file.sh#L188)
		+ [getopts从命令中获取这些参数选项，并且删去了“-”，并将其赋值在getopts第二个参数中，#L189](.//04_examples_args/args_file.sh#L189)
		+ [如果选项带有自己参数，这个参数赋值在“OPTARG”中。#L190](.//04_examples_args/args_file.sh#L190)
		+ [变量$OPTARG存储相应选项的参数，而$OPTIND总是存储原始$*中下一个要处理的元素位置。#L191](.//04_examples_args/args_file.sh#L191)
		+ [output:#L244](.//04_examples_args/args_file.sh#L244)
		+ [参数列表：				-a 11 -b -c start help -h --debug#L246](.//04_examples_args/args_file.sh#L246)
		+ [params：./args_file.sh -a 11 -b -c start help -h --debug#L247](.//04_examples_args/args_file.sh#L247)
		+ [选项：a ->参数值：11， 下一个参数位置：3，参数或选项：-b#L248](.//04_examples_args/args_file.sh#L248)
		+ [选项：b ->下一个参数位置：4，参数或选项：-b#L249](.//04_examples_args/args_file.sh#L249)
		+ [选项：c ->下一个参数位置：5，参数或选项：-c#L250](.//04_examples_args/args_file.sh#L250)
		+ [下一个参数位置：5#L251](.//04_examples_args/args_file.sh#L251)
		+ [清理前参数列表：-a 11 -b -c start help -h --debug#L252](.//04_examples_args/args_file.sh#L252)
		+ [文件：./args_file.sh#L253](.//04_examples_args/args_file.sh#L253)
		+ [清理后参数列表：start help -h --debug#L254](.//04_examples_args/args_file.sh#L254)
		+ [示例：getopt（一个外部工具）#L260](.//04_examples_args/args_file.sh#L260)
		+ [具体用用法查看手册： man getopt#L262](.//04_examples_args/args_file.sh#L262)
		+ [-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项，如：-carg 而不能是-c arg#L263](.//04_examples_args/args_file.sh#L263)
		+ [--long表示长选项，长选项参数传递和短选项不同，如：--debug true#L264](.//04_examples_args/args_file.sh#L264)
		+ [getoptExample --b-long abc -a -c33 hahahaha#L321](.//04_examples_args/args_file.sh#L321)
		+ [output:#L323](.//04_examples_args/args_file.sh#L323)
		+ [参数列表：--b-long abc -a -c33 hahahaha#L325](.//04_examples_args/args_file.sh#L325)
		+ [转换后temp参数： --b-long 'abc' -a -c '33' -- 'hahahaha'#L326](.//04_examples_args/args_file.sh#L326)
		+ [转换后参数列表：--b-long abc -a -c 33 -- hahahaha#L327](.//04_examples_args/args_file.sh#L327)
		+ [option b, argument `abc'#L328](.//04_examples_args/args_file.sh#L328)
		+ [option a#L329](.//04_examples_args/args_file.sh#L329)
		+ [option c, argument `33'#L330](.//04_examples_args/args_file.sh#L330)
		+ [remaining arguments:#L331](.//04_examples_args/args_file.sh#L331)
		+ [下面 -b 两种传入方式都可以#L335](.//04_examples_args/args_file.sh#L335)
		+ [getoptExample -a -b hello -cworld 2333 bash_shell#L336](.//04_examples_args/args_file.sh#L336)
		+ [getoptExample -a -bhello -cworld 2333 bash_shell#L337](.//04_examples_args/args_file.sh#L337)
		+ [output:#L339](.//04_examples_args/args_file.sh#L339)
		+ [参数列表：-a -bhello -cworld 2333 bash_shell#L341](.//04_examples_args/args_file.sh#L341)
		+ [转换后temp参数： -a -b 'hello' -c 'world' -- '2333' 'bash_shell'#L342](.//04_examples_args/args_file.sh#L342)
		+ [转换后参数列表：-a -b hello -c world -- 2333 bash_shell#L343](.//04_examples_args/args_file.sh#L343)
		+ [option a#L344](.//04_examples_args/args_file.sh#L344)
		+ [option b, argument `hello'#L345](.//04_examples_args/args_file.sh#L345)
		+ [option c, argument `world'#L347](.//04_examples_args/args_file.sh#L347)
		+ [remaining arguments:#L348](.//04_examples_args/args_file.sh#L348)
		+ [同样长选项一样使用，长选项"可选参数"传参数要用“=”号#L353](.//04_examples_args/args_file.sh#L353)
		+ [getoptExample --a-long --b-long hello --c-long=world 2333 666 bash_shell example#L354](.//04_examples_args/args_file.sh#L354)
		+ [output:#L356](.//04_examples_args/args_file.sh#L356)
		+ [参数列表：--a-long --b-long hello --c-long=world 2333 666 bash_shell example#L358](.//04_examples_args/args_file.sh#L358)
		+ [转换后temp参数： --a-long --b-long 'hello' --c-long 'world' -- '2333' '666' 'bash_shell' 'example'#L359](.//04_examples_args/args_file.sh#L359)
		+ [转换后参数列表：--a-long --b-long hello --c-long world -- 2333 666 bash_shell example#L360](.//04_examples_args/args_file.sh#L360)
		+ [option a#L361](.//04_examples_args/args_file.sh#L361)
		+ [option b, argument `hello'#L362](.//04_examples_args/args_file.sh#L362)
		+ [option c, argument `world'#L364](.//04_examples_args/args_file.sh#L364)
		+ [remaining arguments:#L365](.//04_examples_args/args_file.sh#L365)
	- [args_input.sh](.//04_examples_args/args_input.sh)
		+ [$0 代表当前执行脚本的文件名#L9](.//04_examples_args/args_input.sh#L9)
		+ [以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名：#L13](.//04_examples_args/args_input.sh#L13)
		+ [为脚本设置可执行权限，并执行脚本，输出结果如下所示：#L21](.//04_examples_args/args_input.sh#L21)
		+ [$ chmod +x args_input.sh#L23](.//04_examples_args/args_input.sh#L23)
		+ [$ ./args_input.sh 1 2 3#L24](.//04_examples_args/args_input.sh#L24)
		+ [输出结果#L26](.//04_examples_args/args_input.sh#L26)
		+ [$ ./args_input.sh 1 2 3#L28](.//04_examples_args/args_input.sh#L28)
		+ [Shell 传递参数实例！#L29](.//04_examples_args/args_input.sh#L29)
		+ [执行的文件名：./args_input.sh#L30](.//04_examples_args/args_input.sh#L30)
		+ [第一个参数为：1#L31](.//04_examples_args/args_input.sh#L31)
		+ [第二个参数为：2#L32](.//04_examples_args/args_input.sh#L32)
		+ [第三个参数为：3#L33](.//04_examples_args/args_input.sh#L33)
	- [args_read.sh](.//04_examples_args/args_read.sh)
		+ [read 命令用于获取键盘输入信息#L11](.//04_examples_args/args_read.sh#L11)
		+ [它的语法形式一般是：#L16](.//04_examples_args/args_read.sh#L16)
		+ [read [-options] [variable...]#L17](.//04_examples_args/args_read.sh#L17)
		+ [read: 用法: read [-ers] [-a 数组] [-d 分隔符] [-i 缓冲区文字] [-n 读取字符数] [-N 读取字符数] [-p 提示符] [-t 超时] [-u 文件描述符] [名称 ...]#L18](.//04_examples_args/args_read.sh#L18)
		+ [以下实例读取键盘输入的内容并将其赋值给shell变量，为：-p 参数由于设置提示信息：#L21](.//04_examples_args/args_read.sh#L21)
		+ [测试结果：#L30](.//04_examples_args/args_read.sh#L30)
		+ [input a val:1#L32](.//04_examples_args/args_read.sh#L32)
		+ [input b val:2#L33](.//04_examples_args/args_read.sh#L33)
		+ [result = 3#L34](.//04_examples_args/args_read.sh#L34)
		+ [read 命令一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔；#L39](.//04_examples_args/args_read.sh#L39)
		+ [如果输入的词组个数大于需要的参数个数，则多出的词组将被作为整体为最后一个参数接收。#L40](.//04_examples_args/args_read.sh#L40)
		+ [测试文件 test.sh 代码如下：#L43](.//04_examples_args/args_read.sh#L43)
		+ [执行测试：#L49](.//04_examples_args/args_read.sh#L49)
		+ [$ sh test.sh#L52](.//04_examples_args/args_read.sh#L52)
		+ [一 二 三 四#L53](.//04_examples_args/args_read.sh#L53)
		+ [第一个参数:一; 第二个参数:二 三 四#L54](.//04_examples_args/args_read.sh#L54)
		+ [实例, 文件 test.sh:#L57](.//04_examples_args/args_read.sh#L57)
		+ [read 参数说明：#L63](.//04_examples_args/args_read.sh#L63)
		+ [$ sh test.sh#L71](.//04_examples_args/args_read.sh#L71)
		+ [请输入一段文字:#L72](.//04_examples_args/args_read.sh#L72)
		+ [password is 123123#L73](.//04_examples_args/args_read.sh#L73)
	- [args_special.sh](.//04_examples_args/args_special.sh)
		+ [$*			以一个单字符串显示所有向脚本传递的参数。#L9](.//04_examples_args/args_special.sh#L9)
		+ [如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。#L10](.//04_examples_args/args_special.sh#L10)
		+ [$$			脚本运行的当前进程ID号#L11](.//04_examples_args/args_special.sh#L11)
		+ [$!			后台运行的最后一个进程的ID号#L12](.//04_examples_args/args_special.sh#L12)
		+ [$@			与$*相同，但是使用时加引号，并在引号中返回每个参数。#L13](.//04_examples_args/args_special.sh#L13)
		+ [如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。#L14](.//04_examples_args/args_special.sh#L14)
		+ [$-			显示Shell使用的当前选项，与set命令功能相同。#L15](.//04_examples_args/args_special.sh#L15)
		+ [$?			显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。#L16](.//04_examples_args/args_special.sh#L16)
		+ [运行脚本，传入参数#L19](.//04_examples_args/args_special.sh#L19)
		+ [$* 与 $@ 区别：#L34](.//04_examples_args/args_special.sh#L34)
		+ [相同点：都是引用所有参数。#L36](.//04_examples_args/args_special.sh#L36)
		+ [不同点：只有在双引号中体现出来。#L37](.//04_examples_args/args_special.sh#L37)
		+ [非数组形式：假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），#L38](.//04_examples_args/args_special.sh#L38)
		+ [数组的形式：而 "@" 等价于 "1" "2" "3"（传递了三个参数）。#L39](.//04_examples_args/args_special.sh#L39)
+ [/05_examples_operator](.//05_examples_operator)
	- [operator_boolean.sh](.//05_examples_operator/operator_boolean.sh)
		+ [!			非运算，表达式为 true 则返回 false，否则返回 true。		[ ! false ] 返回 true。#L10](.//05_examples_operator/operator_boolean.sh#L10)
		+ [&&		逻辑的 AND											[[ $a -lt 100 && $b -gt 100 ]] 返回 false#L14](.//05_examples_operator/operator_boolean.sh#L14)
		+ [||		逻辑的 OR											[[ $a -lt 100 || $b -gt 100 ]] 返回 true#L15](.//05_examples_operator/operator_boolean.sh#L15)
		+ [实例#L20](.//05_examples_operator/operator_boolean.sh#L20)
		+ [布尔运算符实例如下：#L22](.//05_examples_operator/operator_boolean.sh#L22)
		+ [执行脚本，输出结果如下所示：#L72](.//05_examples_operator/operator_boolean.sh#L72)
		+ [10 != 20 : a 不等于 b#L75](.//05_examples_operator/operator_boolean.sh#L75)
		+ [10 小于 100 且 20 大于 15 : 返回 true#L76](.//05_examples_operator/operator_boolean.sh#L76)
		+ [10 小于 100 或 20 大于 100 : 返回 true#L77](.//05_examples_operator/operator_boolean.sh#L77)
		+ [10 小于 5 或 20 大于 100 : 返回 false#L78](.//05_examples_operator/operator_boolean.sh#L78)
	- [operator_file.sh](.//05_examples_operator/operator_file.sh)
		+ [#L9](.//05_examples_operator/operator_file.sh#L9)
		+ [操作符			说明																		举例#L10](.//05_examples_operator/operator_file.sh#L10)
		+ [file1 -nt file2      file1 比 file2 更新#L28](.//05_examples_operator/operator_file.sh#L28)
		+ [file1 -ot file2      file1 比 file2 更老#L29](.//05_examples_operator/operator_file.sh#L29)
		+ [实例#L34](.//05_examples_operator/operator_file.sh#L34)
		+ [变量 file 表示文件"./operator_file.sh"，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：#L36](.//05_examples_operator/operator_file.sh#L36)
		+ [file1 -nt file2      file1 比 file2 更新#L97](.//05_examples_operator/operator_file.sh#L97)
		+ [file1 -ot file2      file1 比 file2 更老#L98](.//05_examples_operator/operator_file.sh#L98)
		+ [执行脚本，输出结果如下所示：#L110](.//05_examples_operator/operator_file.sh#L110)
		+ [文件可读#L113](.//05_examples_operator/operator_file.sh#L113)
		+ [文件可写#L114](.//05_examples_operator/operator_file.sh#L114)
		+ [文件可执行#L115](.//05_examples_operator/operator_file.sh#L115)
		+ [文件为普通文件#L116](.//05_examples_operator/operator_file.sh#L116)
		+ [文件不是个目录#L117](.//05_examples_operator/operator_file.sh#L117)
		+ [文件不为空#L118](.//05_examples_operator/operator_file.sh#L118)
		+ [文件存在#L119](.//05_examples_operator/operator_file.sh#L119)
	- [operator_math.sh](.//05_examples_operator/operator_math.sh)
		+ [+				加法										`expr $a + $b` 结果为 30。#L10](.//05_examples_operator/operator_math.sh#L10)
		+ [*				乘法										`expr $a \* $b` 结果为  200。#L12](.//05_examples_operator/operator_math.sh#L12)
		+ [/				除法										`expr $b / $a` 结果为 2。#L13](.//05_examples_operator/operator_math.sh#L13)
		+ [%				取余										`expr $b % $a` 结果为 0。#L14](.//05_examples_operator/operator_math.sh#L14)
		+ [!=			不相等。用于比较两个数字，不相同则返回 true。	[ $a != $b ] 返回 true。#L17](.//05_examples_operator/operator_math.sh#L17)
		+ [#L19](.//05_examples_operator/operator_math.sh#L19)
		+ [注意：条件表达式要放在方括号之间，并且要有空格，#L20](.//05_examples_operator/operator_math.sh#L20)
		+ [例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。#L21](.//05_examples_operator/operator_math.sh#L21)
		+ [实例#L28](.//05_examples_operator/operator_math.sh#L28)
		+ [算术运算符实例如下：#L30](.//05_examples_operator/operator_math.sh#L30)
		+ [执行脚本，输出结果如下所示：#L61](.//05_examples_operator/operator_math.sh#L61)
		+ [a + b : 30#L64](.//05_examples_operator/operator_math.sh#L64)
		+ [a - b : -10#L65](.//05_examples_operator/operator_math.sh#L65)
		+ [a * b : 200#L66](.//05_examples_operator/operator_math.sh#L66)
		+ [b / a : 2#L67](.//05_examples_operator/operator_math.sh#L67)
		+ [b % a : 0#L68](.//05_examples_operator/operator_math.sh#L68)
		+ [a 不等于 b#L69](.//05_examples_operator/operator_math.sh#L69)
		+ [注意：#L72](.//05_examples_operator/operator_math.sh#L72)
		+ [乘号(*)前边必须加反斜杠(\)转义才能实现乘法运算；#L74](.//05_examples_operator/operator_math.sh#L74)
		+ [if...then...fi 是条件语句，后续将会讲解。#L75](.//05_examples_operator/operator_math.sh#L75)
		+ [在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 "*" 不需要转义符号 "\" 。#L76](.//05_examples_operator/operator_math.sh#L76)
	- [operator_overview.sh](.//05_examples_operator/operator_overview.sh)
		+ [关系运算符#L9](.//05_examples_operator/operator_overview.sh#L9)
		+ [布尔运算符#L10](.//05_examples_operator/operator_overview.sh#L10)
		+ [字符串运算符#L11](.//05_examples_operator/operator_overview.sh#L11)
		+ [文件测试运算符#L12](.//05_examples_operator/operator_overview.sh#L12)
		+ [#L13](.//05_examples_operator/operator_overview.sh#L13)
		+ [原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。#L14](.//05_examples_operator/operator_overview.sh#L14)
		+ [expr 是一款表达式计算工具，使用它能完成表达式的求值操作。#L15](.//05_examples_operator/operator_overview.sh#L15)
		+ [例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：#L19](.//05_examples_operator/operator_overview.sh#L19)
		+ [运行实例 »#L24](.//05_examples_operator/operator_overview.sh#L24)
		+ [执行脚本，输出结果如下所示：#L26](.//05_examples_operator/operator_overview.sh#L26)
		+ [#L27](.//05_examples_operator/operator_overview.sh#L27)
		+ [两数之和为 : 4#L28](.//05_examples_operator/operator_overview.sh#L28)
		+ [两点注意：#L31](.//05_examples_operator/operator_overview.sh#L31)
		+ [表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。#L34](.//05_examples_operator/operator_overview.sh#L34)
		+ [完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。#L35](.//05_examples_operator/operator_overview.sh#L35)
	- [operator_relation.sh](.//05_examples_operator/operator_relation.sh)
		+ [下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：#L9](.//05_examples_operator/operator_relation.sh#L9)
		+ [运算符		说明														举例#L11](.//05_examples_operator/operator_relation.sh#L11)
		+ [EQ 就是 EQUAL等于#L20](.//05_examples_operator/operator_relation.sh#L20)
		+ [NE 就是 NOT EQUAL不等于#L21](.//05_examples_operator/operator_relation.sh#L21)
		+ [GT 就是 GREATER THAN大于#L22](.//05_examples_operator/operator_relation.sh#L22)
		+ [LT 就是 LESS THAN小于#L23](.//05_examples_operator/operator_relation.sh#L23)
		+ [GE 就是 GREATER THAN OR EQUAL 大于等于#L24](.//05_examples_operator/operator_relation.sh#L24)
		+ [LE 就是 LESS THAN OR EQUAL 小于等于#L25](.//05_examples_operator/operator_relation.sh#L25)
		+ [1、进行数值比较时，可以使用 [ expression1 OP expression2 ]，OP 可以为 -gt、-lt、-ge、-le、-eq、-ne#L27](.//05_examples_operator/operator_relation.sh#L27)
		+ [也可以使用 ((expression1 OP expression2))，OP 可以为 >、<、>=、<=、==、!=。#L28](.//05_examples_operator/operator_relation.sh#L28)
		+ [这几个关系运算符都是测试整数表达式 expression1 和 expression2 之间的大小关系。#L29](.//05_examples_operator/operator_relation.sh#L29)
		+ [2、 >、<、==、!= 也可以进行字符串比较。#L31](.//05_examples_operator/operator_relation.sh#L31)
		+ [3、进行字符串比较时，== 可以使用 = 替代。#L32](.//05_examples_operator/operator_relation.sh#L32)
		+ [4、 == 和 !=进行字符串比较时，可以使用 [ string1 OP string2 ] 或者 [[ string1 OP string2 ]] 的形式。#L33](.//05_examples_operator/operator_relation.sh#L33)
		+ [5、 > 和 < 进行字符串比较时，需要使用[[ string1 OP string2 ]] 或者 [ string1 \OP string2 ]。也就是使用 [] 时，> 和 < 需要使用反斜线转义。#L34](.//05_examples_operator/operator_relation.sh#L34)
		+ [实例#L40](.//05_examples_operator/operator_relation.sh#L40)
		+ [关系运算符实例如下：#L42](.//05_examples_operator/operator_relation.sh#L42)
		+ [执行脚本，输出结果如下所示：#L125](.//05_examples_operator/operator_relation.sh#L125)
		+ [10 -eq 20: a 不等于 b#L128](.//05_examples_operator/operator_relation.sh#L128)
		+ [10 -ne 20: a 不等于 b#L129](.//05_examples_operator/operator_relation.sh#L129)
		+ [10 -gt 20: a 不大于 b#L130](.//05_examples_operator/operator_relation.sh#L130)
		+ [10 -lt 20: a 小于 b#L131](.//05_examples_operator/operator_relation.sh#L131)
		+ [10 -ge 20: a 小于 b#L132](.//05_examples_operator/operator_relation.sh#L132)
		+ [10 -le 20: a 小于或等于 b#L133](.//05_examples_operator/operator_relation.sh#L133)
	- [operator_string.sh](.//05_examples_operator/operator_string.sh)
		+ [运算符				说明										举例#L9](.//05_examples_operator/operator_string.sh#L9)
		+ [!=		检测两个字符串是否相等，不相等返回 true。		[ $a != $b ] 返回 true。#L12](.//05_examples_operator/operator_string.sh#L12)
		+ [str		检测字符串是否为空，不为空返回 true。			[ $a ] 返回 true。#L15](.//05_examples_operator/operator_string.sh#L15)
		+ [实例#L22](.//05_examples_operator/operator_string.sh#L22)
		+ [字符串运算符实例如下：#L24](.//05_examples_operator/operator_string.sh#L24)
		+ [执行脚本，输出结果如下所示：#L68](.//05_examples_operator/operator_string.sh#L68)
		+ [abc = efg: a 不等于 b#L71](.//05_examples_operator/operator_string.sh#L71)
		+ [abc != efg : a 不等于 b#L72](.//05_examples_operator/operator_string.sh#L72)
		+ [abc : 字符串不为空#L75](.//05_examples_operator/operator_string.sh#L75)
+ [/06_examples_output](.//06_examples_output)
	- [echo_output.sh](.//06_examples_output/echo_output.sh)
		+ [命令格式：#L9](.//06_examples_output/echo_output.sh#L9)
		+ [echo string#L10](.//06_examples_output/echo_output.sh#L10)
		+ [#L11](.//06_examples_output/echo_output.sh#L11)
		+ [echo -e 开启转义#L12](.//06_examples_output/echo_output.sh#L12)
		+ [echo -n 不换行#L13](.//06_examples_output/echo_output.sh#L13)
		+ [#L14](.//06_examples_output/echo_output.sh#L14)
		+ [可以使用echo实现更复杂的输出格式控制#L15](.//06_examples_output/echo_output.sh#L15)
		+ [echo输出的字符串总结#L18](.//06_examples_output/echo_output.sh#L18)
		+ [能否引用变量  |  能否引用转移符  	|  能否引用文本格式符(如：换行符、制表符)#L20](.//06_examples_output/echo_output.sh#L20)
		+ [单引号  |           否           |             否             |                             否#L22](.//06_examples_output/echo_output.sh#L22)
		+ [双引号  |           能           |             能             |                             能#L23](.//06_examples_output/echo_output.sh#L23)
		+ [无引号  |           能           |             能             |                             否#L24](.//06_examples_output/echo_output.sh#L24)
		+ [1.显示普通字符串:#L31](.//06_examples_output/echo_output.sh#L31)
		+ [这里的双引号完全可以省略，以下命令与上面实例效果一致：#L35](.//06_examples_output/echo_output.sh#L35)
		+ [echo It is a test#L36](.//06_examples_output/echo_output.sh#L36)
		+ [2.显示转义字符#L40](.//06_examples_output/echo_output.sh#L40)
		+ [结果将是:#L44](.//06_examples_output/echo_output.sh#L44)
		+ ["It is a test"#L45](.//06_examples_output/echo_output.sh#L45)
		+ [同样，双引号也可以省略#L46](.//06_examples_output/echo_output.sh#L46)
		+ [3.显示变量#L50](.//06_examples_output/echo_output.sh#L50)
		+ [read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量#L52](.//06_examples_output/echo_output.sh#L52)
		+ [以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:#L57](.//06_examples_output/echo_output.sh#L57)
		+ [[root@www ~] sh test.sh#L59](.//06_examples_output/echo_output.sh#L59)
		+ [OK                     标准输入#L60](.//06_examples_output/echo_output.sh#L60)
		+ [OK It is a test        输出#L61](.//06_examples_output/echo_output.sh#L61)
		+ [4.显示换行#L65](.//06_examples_output/echo_output.sh#L65)
		+ [输出结果：#L70](.//06_examples_output/echo_output.sh#L70)
		+ [OK!#L71](.//06_examples_output/echo_output.sh#L71)
		+ [It it a test#L73](.//06_examples_output/echo_output.sh#L73)
		+ [5.显示不换行#L77](.//06_examples_output/echo_output.sh#L77)
		+ [输出结果：#L83](.//06_examples_output/echo_output.sh#L83)
		+ [OK! It is a test#L84](.//06_examples_output/echo_output.sh#L84)
		+ [6.显示结果定向至文件，将内容写入到文件#L88](.//06_examples_output/echo_output.sh#L88)
		+ [7.单引号原样输出字符串，不进行转义或取变量(用单引号)#L94](.//06_examples_output/echo_output.sh#L94)
		+ [输出结果：#L98](.//06_examples_output/echo_output.sh#L98)
		+ [$name\"#L99](.//06_examples_output/echo_output.sh#L99)
		+ [8.显示命令执行结果#L103](.//06_examples_output/echo_output.sh#L103)
		+ [`` 可以将命令运行在 echo 中#L107](.//06_examples_output/echo_output.sh#L107)
		+ [注意： 这里使用的是反引号 `, 而不是单引号 '。#L110](.//06_examples_output/echo_output.sh#L110)
		+ [结果将显示当前日期#L111](.//06_examples_output/echo_output.sh#L111)
		+ [Thu Jul 24 10:08:46 CST 2014#L113](.//06_examples_output/echo_output.sh#L113)
	- [printfc_output.sh](.//06_examples_output/printfc_output.sh)
		+ [\b	后退,相当于删除前一个字符#L9](.//06_examples_output/printfc_output.sh#L9)
		+ [\c	抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），#L10](.//06_examples_output/printfc_output.sh#L10)
		+ [而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略#L11](.//06_examples_output/printfc_output.sh#L11)
		+ [\f	换页（formfeed）#L12](.//06_examples_output/printfc_output.sh#L12)
		+ [\n	换行#L13](.//06_examples_output/printfc_output.sh#L13)
		+ [\r	回车（Carriage return）#L14](.//06_examples_output/printfc_output.sh#L14)
		+ [\t	水平制表符#L15](.//06_examples_output/printfc_output.sh#L15)
		+ [\v	垂直制表符#L16](.//06_examples_output/printfc_output.sh#L16)
		+ [\\	一个字面上的反斜杠字符#L17](.//06_examples_output/printfc_output.sh#L17)
		+ [\ddd	表示1到3位数八进制值的字符。仅在格式字符串中有效#L18](.//06_examples_output/printfc_output.sh#L18)
		+ [\0ddd	表示1到3位的八进制值字符#L19](.//06_examples_output/printfc_output.sh#L19)
		+ [实例#L21](.//06_examples_output/printfc_output.sh#L21)
		+ [a string, no processing:<A\nB>#L24](.//06_examples_output/printfc_output.sh#L24)
		+ [a string, no processing:<A#L27](.//06_examples_output/printfc_output.sh#L27)
		+ [B>#L28](.//06_examples_output/printfc_output.sh#L28)
		+ [www.xxx.com $                  不换行#L31](.//06_examples_output/printfc_output.sh#L31)
	- [printf_output.sh](.//06_examples_output/printf_output.sh)
		+ [还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。#L9](.//06_examples_output/printf_output.sh#L9)
		+ [printf 命令的语法：#L11](.//06_examples_output/printf_output.sh#L11)
		+ [printf  format-string  [arguments...]#L12](.//06_examples_output/printf_output.sh#L12)
		+ [参数说明：#L13](.//06_examples_output/printf_output.sh#L13)
		+ [format-string: 为格式控制字符串#L14](.//06_examples_output/printf_output.sh#L14)
		+ [arguments: 为参数列表。#L15](.//06_examples_output/printf_output.sh#L15)
		+ [%d %s %c %f 格式替代符详解:#L17](.//06_examples_output/printf_output.sh#L17)
		+ [d: Decimal 十进制整数 -- 对应位置参数必须是十进制整数，否则报错！#L19](.//06_examples_output/printf_output.sh#L19)
		+ [s: String 字符串 -- 对应位置参数必须是字符串或者字符型，否则报错！#L20](.//06_examples_output/printf_output.sh#L20)
		+ [c: Char 字符 -- 对应位置参数必须是字符串或者字符型，否则报错！#L21](.//06_examples_output/printf_output.sh#L21)
		+ [f: Float 浮点 -- 对应位置参数必须是数字型，否则报错！#L22](.//06_examples_output/printf_output.sh#L22)
		+ [如：其中最后一个参数是 "def"，%c 自动截取字符串的第一个字符作为结果输出。#L25](.//06_examples_output/printf_output.sh#L25)
		+ [实例如下：#L31](.//06_examples_output/printf_output.sh#L31)
		+ [接下来,我来用一个脚本来体现printf的强大功能：#L40](.//06_examples_output/printf_output.sh#L40)
		+ [执行脚本，输出结果如下所示：#L49](.//06_examples_output/printf_output.sh#L49)
		+ [姓名     性别   体重kg#L52](.//06_examples_output/printf_output.sh#L52)
		+ [郭靖     男      66.12#L53](.//06_examples_output/printf_output.sh#L53)
		+ [杨过     男      48.65#L54](.//06_examples_output/printf_output.sh#L54)
		+ [郭芙     女      47.99#L55](.//06_examples_output/printf_output.sh#L55)
		+ [%s %c %d %f都是格式替代符#L59](.//06_examples_output/printf_output.sh#L59)
		+ [%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。#L60](.//06_examples_output/printf_output.sh#L60)
		+ [%-4.2f 指格式化为小数，其中.2指保留2位小数。#L61](.//06_examples_output/printf_output.sh#L61)
		+ [更多实例：#L65](.//06_examples_output/printf_output.sh#L65)
		+ [format-string为双引号#L68](.//06_examples_output/printf_output.sh#L68)
		+ [单引号与双引号效果一样#L71](.//06_examples_output/printf_output.sh#L71)
		+ [没有引号也可以输出#L74](.//06_examples_output/printf_output.sh#L74)
		+ [格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用#L77](.//06_examples_output/printf_output.sh#L77)
		+ [如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替#L84](.//06_examples_output/printf_output.sh#L84)
		+ [执行脚本，输出结果如下所示：#L88](.//06_examples_output/printf_output.sh#L88)
		+ [1 abc#L91](.//06_examples_output/printf_output.sh#L91)
		+ [1 abc#L92](.//06_examples_output/printf_output.sh#L92)
		+ [abcdefabcdefabc#L93](.//06_examples_output/printf_output.sh#L93)
		+ [def#L94](.//06_examples_output/printf_output.sh#L94)
		+ [a b c#L95](.//06_examples_output/printf_output.sh#L95)
		+ [d e f#L96](.//06_examples_output/printf_output.sh#L96)
		+ [g h i#L97](.//06_examples_output/printf_output.sh#L97)
		+ [j#L98](.//06_examples_output/printf_output.sh#L98)
		+ [and 0#L99](.//06_examples_output/printf_output.sh#L99)
+ [/07_examples_test](.//07_examples_test)
	- [test_file.sh](.//07_examples_test/test_file.sh)
		+ [参数							说明#L9](.//07_examples_test/test_file.sh#L9)
		+ [实例演示：#L24](.//07_examples_test/test_file.sh#L24)
		+ [另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，#L75](.//07_examples_test/test_file.sh#L75)
		+ [其优先级为："!"最高，"-a"次之，"-o"最低。#L76](.//07_examples_test/test_file.sh#L76)
		+ [输出结果：#L88](.//07_examples_test/test_file.sh#L88)
		+ [至少有一个文件存在!#L90](.//07_examples_test/test_file.sh#L90)
	- [test_math.sh](.//07_examples_test/test_math.sh)
		+ [参数				说明#L10](.//07_examples_test/test_math.sh#L10)
		+ [实例演示：#L24](.//07_examples_test/test_math.sh#L24)
		+ [输出结果：#L59](.//07_examples_test/test_math.sh#L59)
		+ [两个数相等！#L61](.//07_examples_test/test_math.sh#L61)
		+ [代码中的 [] 执行基本的算数运算，如：#L65](.//07_examples_test/test_math.sh#L65)
	- [test_string.sh](.//07_examples_test/test_string.sh)
		+ [参数					说明#L10](.//07_examples_test/test_string.sh#L10)
		+ [!=			不相等				则为真#L13](.//07_examples_test/test_string.sh#L13)
		+ [实例演示：#L21](.//07_examples_test/test_string.sh#L21)
		+ [输出结果：#L46](.//07_examples_test/test_string.sh#L46)
		+ [两个字符串不相等!#L48](.//07_examples_test/test_string.sh#L48)
+ [/08_examples_process](.//08_examples_process)
	- [each.sh](.//08_examples_process/each.sh)
	- [process_case.sh](.//08_examples_process/process_case.sh)
		+ [case语句格式如下：#L9](.//08_examples_process/process_case.sh#L9)
		+ [case 值 in#L11](.//08_examples_process/process_case.sh#L11)
		+ [模式1)#L12](.//08_examples_process/process_case.sh#L12)
		+ [command1#L13](.//08_examples_process/process_case.sh#L13)
		+ [command2#L14](.//08_examples_process/process_case.sh#L14)
		+ [...#L15](.//08_examples_process/process_case.sh#L15)
		+ [commandN#L16](.//08_examples_process/process_case.sh#L16)
		+ [;;#L17](.//08_examples_process/process_case.sh#L17)
		+ [模式2)#L18](.//08_examples_process/process_case.sh#L18)
		+ [command1#L19](.//08_examples_process/process_case.sh#L19)
		+ [command2#L20](.//08_examples_process/process_case.sh#L20)
		+ [...#L21](.//08_examples_process/process_case.sh#L21)
		+ [commandN#L22](.//08_examples_process/process_case.sh#L22)
		+ [;;#L23](.//08_examples_process/process_case.sh#L23)
		+ [esac#L24](.//08_examples_process/process_case.sh#L24)
		+ [case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。#L27](.//08_examples_process/process_case.sh#L27)
		+ [取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。#L28](.//08_examples_process/process_case.sh#L28)
		+ [取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。#L30](.//08_examples_process/process_case.sh#L30)
		+ [如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。#L31](.//08_examples_process/process_case.sh#L31)
		+ [esac#L35](.//08_examples_process/process_case.sh#L35)
		+ [case的语法和Java family语言差别很大，#L37](.//08_examples_process/process_case.sh#L37)
		+ [它需要一个esac（就是case反过来）作为结束标记，#L38](.//08_examples_process/process_case.sh#L38)
		+ [每个case分支用右圆括号，用两个分号表示break。#L39](.//08_examples_process/process_case.sh#L39)
		+ [下面的脚本提示输入1到4，与每一种模式进行匹配：#L41](.//08_examples_process/process_case.sh#L41)
		+ [输入不同的内容，会有不同的结果，例如：#L67](.//08_examples_process/process_case.sh#L67)
		+ [输入 1 到 4 之间的数字:#L69](.//08_examples_process/process_case.sh#L69)
		+ [你输入的数字为:#L70](.//08_examples_process/process_case.sh#L70)
		+ [3#L71](.//08_examples_process/process_case.sh#L71)
		+ [你选择了 3#L72](.//08_examples_process/process_case.sh#L72)
	- [process_for.sh](.//08_examples_process/process_for.sh)
		+ [for循环一般格式为：#L12](.//08_examples_process/process_for.sh#L12)
		+ [for var in item1 item2 ... itemN#L14](.//08_examples_process/process_for.sh#L14)
		+ [do#L15](.//08_examples_process/process_for.sh#L15)
		+ [command1#L16](.//08_examples_process/process_for.sh#L16)
		+ [command2#L17](.//08_examples_process/process_for.sh#L17)
		+ [...#L18](.//08_examples_process/process_for.sh#L18)
		+ [commandN#L19](.//08_examples_process/process_for.sh#L19)
		+ [done#L20](.//08_examples_process/process_for.sh#L20)
		+ [for((assignment;condition:next));do#L22](.//08_examples_process/process_for.sh#L22)
		+ [command_1;#L23](.//08_examples_process/process_for.sh#L23)
		+ [command_2;#L24](.//08_examples_process/process_for.sh#L24)
		+ [commond_..;#L25](.//08_examples_process/process_for.sh#L25)
		+ [done;#L26](.//08_examples_process/process_for.sh#L26)
		+ [写成一行：#L29](.//08_examples_process/process_for.sh#L29)
		+ [for var in item1 item2 ... itemN; do command1; command2… done;#L31](.//08_examples_process/process_for.sh#L31)
		+ [当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。#L33](.//08_examples_process/process_for.sh#L33)
		+ [命令可为任何有效的shell命令和语句。#L34](.//08_examples_process/process_for.sh#L34)
		+ [#L35](.//08_examples_process/process_for.sh#L35)
		+ [in列表可以包含替换、字符串和文件名。#L36](.//08_examples_process/process_for.sh#L36)
		+ [in列表是可选的，如果不用它，for循环使用命令行的位置参数。#L37](.//08_examples_process/process_for.sh#L37)
		+ [例如，顺序输出当前列表中的数字：#L43](.//08_examples_process/process_for.sh#L43)
		+ [输出结果：#L51](.//08_examples_process/process_for.sh#L51)
		+ [The value is: 1#L54](.//08_examples_process/process_for.sh#L54)
		+ [The value is: 2#L55](.//08_examples_process/process_for.sh#L55)
		+ [The value is: 3#L56](.//08_examples_process/process_for.sh#L56)
		+ [The value is: 4#L57](.//08_examples_process/process_for.sh#L57)
		+ [The value is: 5#L58](.//08_examples_process/process_for.sh#L58)
		+ [顺序输出字符串中的字符：#L60](.//08_examples_process/process_for.sh#L60)
		+ [每个空格代表一个元素#L68](.//08_examples_process/process_for.sh#L68)
		+ [输出结果：#L74](.//08_examples_process/process_for.sh#L74)
		+ [This is a string#L76](.//08_examples_process/process_for.sh#L76)
		+ [This\t#L79](.//08_examples_process/process_for.sh#L79)
		+ [is\t#L80](.//08_examples_process/process_for.sh#L80)
		+ [a\t#L81](.//08_examples_process/process_for.sh#L81)
		+ [string\t#L82](.//08_examples_process/process_for.sh#L82)
		+ [执行结果：#L89](.//08_examples_process/process_for.sh#L89)
		+ [这是第1次调用#L91](.//08_examples_process/process_for.sh#L91)
		+ [这是第2次调用#L92](.//08_examples_process/process_for.sh#L92)
		+ [这是第3次调用#L93](.//08_examples_process/process_for.sh#L93)
		+ [这是第4次调用#L94](.//08_examples_process/process_for.sh#L94)
		+ [这是第5次调用#L95](.//08_examples_process/process_for.sh#L95)
	- [process_ifelse.sh](.//08_examples_process/process_ifelse.sh)
		+ [if#L9](.//08_examples_process/process_ifelse.sh#L9)
		+ [if 语句语法格式：#L11](.//08_examples_process/process_ifelse.sh#L11)
		+ [if condition#L13](.//08_examples_process/process_ifelse.sh#L13)
		+ [then#L14](.//08_examples_process/process_ifelse.sh#L14)
		+ [command1#L15](.//08_examples_process/process_ifelse.sh#L15)
		+ [command2#L16](.//08_examples_process/process_ifelse.sh#L16)
		+ [...#L17](.//08_examples_process/process_ifelse.sh#L17)
		+ [commandN#L18](.//08_examples_process/process_ifelse.sh#L18)
		+ [fi#L19](.//08_examples_process/process_ifelse.sh#L19)
		+ [写成一行（适用于终端命令提示符）：#L23](.//08_examples_process/process_ifelse.sh#L23)
		+ [if else#L29](.//08_examples_process/process_ifelse.sh#L29)
		+ [if else 语法格式：#L31](.//08_examples_process/process_ifelse.sh#L31)
		+ [if condition#L33](.//08_examples_process/process_ifelse.sh#L33)
		+ [then#L34](.//08_examples_process/process_ifelse.sh#L34)
		+ [command1#L35](.//08_examples_process/process_ifelse.sh#L35)
		+ [command2#L36](.//08_examples_process/process_ifelse.sh#L36)
		+ [...#L37](.//08_examples_process/process_ifelse.sh#L37)
		+ [commandN#L38](.//08_examples_process/process_ifelse.sh#L38)
		+ [else#L39](.//08_examples_process/process_ifelse.sh#L39)
		+ [command#L40](.//08_examples_process/process_ifelse.sh#L40)
		+ [fi#L41](.//08_examples_process/process_ifelse.sh#L41)
		+ [if else-if else#L46](.//08_examples_process/process_ifelse.sh#L46)
		+ [if else-if else 语法格式：#L48](.//08_examples_process/process_ifelse.sh#L48)
		+ [if condition1#L51](.//08_examples_process/process_ifelse.sh#L51)
		+ [then#L52](.//08_examples_process/process_ifelse.sh#L52)
		+ [command1#L53](.//08_examples_process/process_ifelse.sh#L53)
		+ [elif condition2#L54](.//08_examples_process/process_ifelse.sh#L54)
		+ [then#L55](.//08_examples_process/process_ifelse.sh#L55)
		+ [command2#L56](.//08_examples_process/process_ifelse.sh#L56)
		+ [else#L57](.//08_examples_process/process_ifelse.sh#L57)
		+ [commandN#L58](.//08_examples_process/process_ifelse.sh#L58)
		+ [fi#L59](.//08_examples_process/process_ifelse.sh#L59)
		+ [以下实例判断两个变量是否相等：#L62](.//08_examples_process/process_ifelse.sh#L62)
		+ [输出结果：#L82](.//08_examples_process/process_ifelse.sh#L82)
		+ [a 小于 b#L83](.//08_examples_process/process_ifelse.sh#L83)
		+ [if else语句经常与test命令结合使用，如下所示：#L86](.//08_examples_process/process_ifelse.sh#L86)
		+ [输出结果：#L98](.//08_examples_process/process_ifelse.sh#L98)
		+ [两个数字相等!#L99](.//08_examples_process/process_ifelse.sh#L99)
	- [process_loop_jump.sh](.//08_examples_process/process_loop_jump.sh)
		+ [break命令#L10](.//08_examples_process/process_loop_jump.sh#L10)
		+ [break命令允许跳出所有循环（终止执行后面的所有循环）。#L12](.//08_examples_process/process_loop_jump.sh#L12)
		+ [下面的例子中，脚本进入死循环直至用户输入数字大于5。#L15](.//08_examples_process/process_loop_jump.sh#L15)
		+ [要跳出这个循环，返回到shell提示符下，需要使用break命令。#L16](.//08_examples_process/process_loop_jump.sh#L16)
		+ [执行以上代码，输出结果为：#L34](.//08_examples_process/process_loop_jump.sh#L34)
		+ [输入 1 到 5 之间的数字:3#L37](.//08_examples_process/process_loop_jump.sh#L37)
		+ [你输入的数字为 3!#L38](.//08_examples_process/process_loop_jump.sh#L38)
		+ [输入 1 到 5 之间的数字:7#L39](.//08_examples_process/process_loop_jump.sh#L39)
		+ [你输入的数字不是 1 到 5 之间的! 游戏结束#L40](.//08_examples_process/process_loop_jump.sh#L40)
		+ [continue#L45](.//08_examples_process/process_loop_jump.sh#L45)
		+ [continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。#L47](.//08_examples_process/process_loop_jump.sh#L47)
		+ [对上面的例子进行修改：#L49](.//08_examples_process/process_loop_jump.sh#L49)
		+ [运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo "游戏结束" 永远不会被执行。#L69](.//08_examples_process/process_loop_jump.sh#L69)
		+ [esac#L72](.//08_examples_process/process_loop_jump.sh#L72)
		+ [case的语法和Java family语言差别很大，#L74](.//08_examples_process/process_loop_jump.sh#L74)
		+ [它需要一个esac（就是case反过来）作为结束标记，#L75](.//08_examples_process/process_loop_jump.sh#L75)
		+ [每个case分支用右圆括号，用两个分号表示break。#L76](.//08_examples_process/process_loop_jump.sh#L76)
	- [process_select.sh](.//08_examples_process/process_select.sh)
		+ [示例1：选择你的操作系统。#L13](.//08_examples_process/process_select.sh#L13)
		+ [一次选择后，break 跳出循环#L14](.//08_examples_process/process_select.sh#L14)
		+ [示例2：RANDOM 随机数#L28](.//08_examples_process/process_select.sh#L28)
		+ [IFS 是内部域分隔符，设置变量 pocket的分隔符#L45](.//08_examples_process/process_select.sh#L45)
		+ [设置回原来的值#L49](.//08_examples_process/process_select.sh#L49)
	- [process_unlimit_loop.sh](.//08_examples_process/process_unlimit_loop.sh)
		+ [无限循环语法格式：#L11](.//08_examples_process/process_unlimit_loop.sh#L11)
		+ [while :#L13](.//08_examples_process/process_unlimit_loop.sh#L13)
		+ [do#L14](.//08_examples_process/process_unlimit_loop.sh#L14)
		+ [command#L15](.//08_examples_process/process_unlimit_loop.sh#L15)
		+ [done#L16](.//08_examples_process/process_unlimit_loop.sh#L16)
		+ [或者#L31](.//08_examples_process/process_unlimit_loop.sh#L31)
		+ [while true#L33](.//08_examples_process/process_unlimit_loop.sh#L33)
		+ [do#L34](.//08_examples_process/process_unlimit_loop.sh#L34)
		+ [command#L35](.//08_examples_process/process_unlimit_loop.sh#L35)
		+ [done#L36](.//08_examples_process/process_unlimit_loop.sh#L36)
		+ [或者#L48](.//08_examples_process/process_unlimit_loop.sh#L48)
		+ [for (( ; ; ))#L49](.//08_examples_process/process_unlimit_loop.sh#L49)
	- [process_until.sh](.//08_examples_process/process_until.sh)
		+ [一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。#L9](.//08_examples_process/process_until.sh#L9)
		+ [until 语法格式:#L13](.//08_examples_process/process_until.sh#L13)
		+ [until condition#L15](.//08_examples_process/process_until.sh#L15)
		+ [do#L16](.//08_examples_process/process_until.sh#L16)
		+ [command#L17](.//08_examples_process/process_until.sh#L17)
		+ [done#L18](.//08_examples_process/process_until.sh#L18)
		+ [condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。#L20](.//08_examples_process/process_until.sh#L20)
		+ [以下实例我们使用 until 命令来输出 0 ~ 9 的数字：#L23](.//08_examples_process/process_until.sh#L23)
		+ [运行结果：#L35](.//08_examples_process/process_until.sh#L35)
		+ [#L36](.//08_examples_process/process_until.sh#L36)
		+ [0#L37](.//08_examples_process/process_until.sh#L37)
		+ [1#L38](.//08_examples_process/process_until.sh#L38)
		+ [2#L39](.//08_examples_process/process_until.sh#L39)
		+ [3#L40](.//08_examples_process/process_until.sh#L40)
		+ [4#L41](.//08_examples_process/process_until.sh#L41)
		+ [5#L42](.//08_examples_process/process_until.sh#L42)
		+ [6#L43](.//08_examples_process/process_until.sh#L43)
		+ [7#L44](.//08_examples_process/process_until.sh#L44)
		+ [8#L45](.//08_examples_process/process_until.sh#L45)
		+ [9#L46](.//08_examples_process/process_until.sh#L46)
	- [process_while.sh](.//08_examples_process/process_while.sh)
		+ [while condition#L10](.//08_examples_process/process_while.sh#L10)
		+ [do#L11](.//08_examples_process/process_while.sh#L11)
		+ [command#L12](.//08_examples_process/process_while.sh#L12)
		+ [done#L13](.//08_examples_process/process_while.sh#L13)
		+ [以下是一个基本的while循环，测试条件是：#L20](.//08_examples_process/process_while.sh#L20)
		+ [如果int小于等于5，那么条件返回真。#L21](.//08_examples_process/process_while.sh#L21)
		+ [int从0开始，每次循环处理时，int加1。#L22](.//08_examples_process/process_while.sh#L22)
		+ [运行上述脚本，返回数字1到5，然后终止。#L23](.//08_examples_process/process_while.sh#L23)
		+ [运行脚本，输出：#L34](.//08_examples_process/process_while.sh#L34)
		+ [1#L36](.//08_examples_process/process_while.sh#L36)
		+ [2#L37](.//08_examples_process/process_while.sh#L37)
		+ [3#L38](.//08_examples_process/process_while.sh#L38)
		+ [4#L39](.//08_examples_process/process_while.sh#L39)
		+ [5#L40](.//08_examples_process/process_while.sh#L40)
		+ [代码中使用了 Bash let 命令，它用于执行一个或多个表达式，#L43](.//08_examples_process/process_while.sh#L43)
		+ [变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令#L44](.//08_examples_process/process_while.sh#L44)
		+ [while循环可用于读取键盘信息。下面的例子中，#L53](.//08_examples_process/process_while.sh#L53)
		+ [输入信息被设置为变量FILM，按<Ctrl-D>结束循环。#L54](.//08_examples_process/process_while.sh#L54)
		+ [运行脚本，输出类似下面：#L65](.//08_examples_process/process_while.sh#L65)
		+ [按下 <CTRL-D> 退出#L68](.//08_examples_process/process_while.sh#L68)
		+ [输入你最喜欢的网站名: baidu#L69](.//08_examples_process/process_while.sh#L69)
		+ [是的！baidu 是一个好网站#L70](.//08_examples_process/process_while.sh#L70)
+ [/09_examples_function](.//09_examples_function)
	- [func_param.sh](.//09_examples_function/func_param.sh)
		+ [例如，$1表示第一个参数，$2表示第二个参数...#L9](.//09_examples_function/func_param.sh#L9)
		+ [注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。#L10](.//09_examples_function/func_param.sh#L10)
		+ [另外，还有几个特殊字符用来处理参数：#L13](.//09_examples_function/func_param.sh#L13)
		+ [参数处理		说明#L15](.//09_examples_function/func_param.sh#L15)
		+ [$		传递到脚本的参数个数#L17](.//09_examples_function/func_param.sh#L17)
		+ [$*		以一个单字符串显示所有向脚本传递的参数#L18](.//09_examples_function/func_param.sh#L18)
		+ [$$		脚本运行的当前进程ID号#L19](.//09_examples_function/func_param.sh#L19)
		+ [$!		后台运行的最后一个进程的ID号#L20](.//09_examples_function/func_param.sh#L20)
		+ [$@		与$*相同，但是使用时加引号，并在引号中返回每个参数。#L21](.//09_examples_function/func_param.sh#L21)
		+ [$-		显示Shell使用的当前选项，与set命令功能相同。#L22](.//09_examples_function/func_param.sh#L22)
		+ [$?		显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。#L23](.//09_examples_function/func_param.sh#L23)
		+ [带参数的函数示例：#L27](.//09_examples_function/func_param.sh#L27)
		+ [输出结果：#L41](.//09_examples_function/func_param.sh#L41)
		+ [第一个参数为 1 !#L43](.//09_examples_function/func_param.sh#L43)
		+ [第二个参数为 2 !#L44](.//09_examples_function/func_param.sh#L44)
		+ [第十个参数为 10 !#L45](.//09_examples_function/func_param.sh#L45)
		+ [第十个参数为 34 !#L46](.//09_examples_function/func_param.sh#L46)
		+ [第十一个参数为 73 !#L47](.//09_examples_function/func_param.sh#L47)
		+ [参数总数有 11 个!#L48](.//09_examples_function/func_param.sh#L48)
		+ [作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !#L49](.//09_examples_function/func_param.sh#L49)
		+ [注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。#L52](.//09_examples_function/func_param.sh#L52)
	- [func_started.sh](.//09_examples_function/func_started.sh)
		+ [shell中函数的定义格式如下：#L9](.//09_examples_function/func_started.sh#L9)
		+ [[ function ] funname [()]#L11](.//09_examples_function/func_started.sh#L11)
		+ [{#L12](.//09_examples_function/func_started.sh#L12)
		+ [action;#L13](.//09_examples_function/func_started.sh#L13)
		+ [[return int;]#L14](.//09_examples_function/func_started.sh#L14)
		+ [}#L15](.//09_examples_function/func_started.sh#L15)
		+ [说明：#L18](.//09_examples_function/func_started.sh#L18)
		+ [1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。#L20](.//09_examples_function/func_started.sh#L20)
		+ [2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255#L21](.//09_examples_function/func_started.sh#L21)
		+ [下面的例子定义了一个函数并进行调用：#L25](.//09_examples_function/func_started.sh#L25)
		+ [输出结果：#L36](.//09_examples_function/func_started.sh#L36)
		+ [这是我的第一个 shell 函数!#L40](.//09_examples_function/func_started.sh#L40)
		+ [下面定义一个带有return语句的函数：#L47](.//09_examples_function/func_started.sh#L47)
		+ [输出类似下面：#L66](.//09_examples_function/func_started.sh#L66)
		+ [这个函数会对输入的两个数字进行相加运算...#L69](.//09_examples_function/func_started.sh#L69)
		+ [输入第一个数字:#L70](.//09_examples_function/func_started.sh#L70)
		+ [1#L71](.//09_examples_function/func_started.sh#L71)
		+ [输入第二个数字:#L72](.//09_examples_function/func_started.sh#L72)
		+ [2#L73](.//09_examples_function/func_started.sh#L73)
		+ [两个数字分别为 1 和 2 !#L74](.//09_examples_function/func_started.sh#L74)
		+ [输入的两个数字之和为 3 !#L75](.//09_examples_function/func_started.sh#L75)
		+ [函数返回值在调用该函数后通过 $? 来获得。#L79](.//09_examples_function/func_started.sh#L79)
		+ [注意：所有函数在使用前必须定义。#L81](.//09_examples_function/func_started.sh#L81)
		+ [这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。#L82](.//09_examples_function/func_started.sh#L82)
		+ [调用函数仅使用其函数名即可。#L83](.//09_examples_function/func_started.sh#L83)
+ [/10_examples_file](.//10_examples_file)
	- [file_dev_null.sh](.//10_examples_file/file_dev_null.sh)
		+ [/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。#L12](.//10_examples_file/file_dev_null.sh#L12)
		+ [但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。#L13](.//10_examples_file/file_dev_null.sh#L13)
		+ [如果希望屏蔽 stdout 和 stderr，可以这样写：#L19](.//10_examples_file/file_dev_null.sh#L19)
		+ [注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。#L22](.//10_examples_file/file_dev_null.sh#L22)
	- [file_eof.sh](.//10_examples_file/file_eof.sh)
		+ [command << delimiter#L10](.//10_examples_file/file_eof.sh#L10)
		+ [document#L11](.//10_examples_file/file_eof.sh#L11)
		+ [delimiter#L12](.//10_examples_file/file_eof.sh#L12)
		+ [它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。#L14](.//10_examples_file/file_eof.sh#L14)
		+ [注意：#L17](.//10_examples_file/file_eof.sh#L17)
		+ [结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。#L19](.//10_examples_file/file_eof.sh#L19)
		+ [开始的delimiter前后的空格会被忽略掉。#L20](.//10_examples_file/file_eof.sh#L20)
		+ [实例#L27](.//10_examples_file/file_eof.sh#L27)
		+ [在命令行中通过 wc -l 命令计算 Here Document 的行数：#L29](.//10_examples_file/file_eof.sh#L29)
		+ [3           输出结果为 3 行#L38](.//10_examples_file/file_eof.sh#L38)
		+ [我们也可以将 Here Document 用在脚本中，例如：#L46](.//10_examples_file/file_eof.sh#L46)
		+ [test.sh#L49](.//10_examples_file/file_eof.sh#L49)
		+ [执行以上脚本，输出结果：#L57](.//10_examples_file/file_eof.sh#L57)
		+ [$ ./test.sh#L58](.//10_examples_file/file_eof.sh#L58)
		+ [welcome#L60](.//10_examples_file/file_eof.sh#L60)
		+ [bash#L61](.//10_examples_file/file_eof.sh#L61)
		+ [world#L62](.//10_examples_file/file_eof.sh#L62)
	- [file_help.sh](.//10_examples_file/file_help.sh)
		+ [实例#L14](.//10_examples_file/file_help.sh#L14)
		+ [in case of error or if -h is given we call the function help:#L25](.//10_examples_file/file_help.sh#L25)
		+ [send the escape sequence to change the xterm titelbar:#L30](.//10_examples_file/file_help.sh#L30)
	- [file_stdin.sh](.//10_examples_file/file_stdin.sh)
		+ [这样，本来需要从键盘获取输入的命令会转移到文件读取内容。#L9](.//10_examples_file/file_stdin.sh#L9)
		+ [#L10](.//10_examples_file/file_stdin.sh#L10)
		+ [注意：输出重定向是大于号(>)，输入重定向是小于号(<)。#L11](.//10_examples_file/file_stdin.sh#L11)
		+ [实例#L17](.//10_examples_file/file_stdin.sh#L17)
		+ [接着以上实例，我们需要统计 users 文件的行数，执行以下命令：#L19](.//10_examples_file/file_stdin.sh#L19)
		+ [2 users#L21](.//10_examples_file/file_stdin.sh#L21)
		+ [也可以将输入重定向到 users 文件：#L23](.//10_examples_file/file_stdin.sh#L23)
		+ [2#L25](.//10_examples_file/file_stdin.sh#L25)
		+ [注意：上面两个例子的结果不同：#L27](.//10_examples_file/file_stdin.sh#L27)
		+ [第一个例子，会输出文件名；#L28](.//10_examples_file/file_stdin.sh#L28)
		+ [第二个不会，因为它仅仅知道从标准输入读取内容。#L29](.//10_examples_file/file_stdin.sh#L29)
		+ [command1 < infile > outfile#L34](.//10_examples_file/file_stdin.sh#L34)
		+ [同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。#L35](.//10_examples_file/file_stdin.sh#L35)
		+ [tips：wc -l 统计 users内容行数，把结果写入到文件stats#L38](.//10_examples_file/file_stdin.sh#L38)
		+ [如果希望 stderr 重定向到 file，可以这样写：#L44](.//10_examples_file/file_stdin.sh#L44)
		+ [$ command 2 > file#L45](.//10_examples_file/file_stdin.sh#L45)
		+ [如果希望 stderr 追加到 file 文件末尾，可以这样写：#L47](.//10_examples_file/file_stdin.sh#L47)
		+ [$ command 2 >> file#L48](.//10_examples_file/file_stdin.sh#L48)
		+ [2 表示标准错误文件(stderr)。#L50](.//10_examples_file/file_stdin.sh#L50)
		+ [如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：#L52](.//10_examples_file/file_stdin.sh#L52)
		+ [或者#L55](.//10_examples_file/file_stdin.sh#L55)
		+ [如果希望对 stdin 和 stdout 都重定向，可以这样写：#L59](.//10_examples_file/file_stdin.sh#L59)
		+ [command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。#L61](.//10_examples_file/file_stdin.sh#L61)
		+ [扩展阅读#L71](.//10_examples_file/file_stdin.sh#L71)
		+ [这里的&没有固定的意思#L76](.//10_examples_file/file_stdin.sh#L76)
		+ [放在>后面的&，表示重定向的目标不是一个文件，而是一个文件描述符，#L77](.//10_examples_file/file_stdin.sh#L77)
		+ [内置的文件描述符如下：#L79](.//10_examples_file/file_stdin.sh#L79)
		+ [1 => stdout#L81](.//10_examples_file/file_stdin.sh#L81)
		+ [2 => stderr#L82](.//10_examples_file/file_stdin.sh#L82)
		+ [0 => stdin#L83](.//10_examples_file/file_stdin.sh#L83)
		+ [换言之 2>1 代表将stderr重定向到当前路径下文件名为1的regular file中，#L86](.//10_examples_file/file_stdin.sh#L86)
		+ [而2>&1代表将stderr重定向到文件描述符为1的文件(即/dev/stdout)中，#L87](.//10_examples_file/file_stdin.sh#L87)
		+ [这个文件就是stdout在file system中的映射#L88](.//10_examples_file/file_stdin.sh#L88)
		+ [而&>file是一种特殊的用法，也可以写成>&file，二者的意思完全相同，都等价于>file 2>&1#L91](.//10_examples_file/file_stdin.sh#L91)
		+ [此处&>或者>&视作整体，分开没有单独的含义#L92](.//10_examples_file/file_stdin.sh#L92)
		+ [顺序问题：#L96](.//10_examples_file/file_stdin.sh#L96)
		+ [我想问为什么不能调下顺序,比如这样#L99](.//10_examples_file/file_stdin.sh#L99)
		+ [这个是从左到右有顺序的#L102](.//10_examples_file/file_stdin.sh#L102)
		+ [第一种#L104](.//10_examples_file/file_stdin.sh#L104)
		+ [先将要输出到stdout的内容重定向到文件，此时文件list就是这个程序的stdout，再将stderr重定向到stdout，也就是文件list#L106](.//10_examples_file/file_stdin.sh#L106)
		+ [第二种#L109](.//10_examples_file/file_stdin.sh#L109)
		+ [先将要输出到stderr的内容重定向到stdout，此时会产生一个stdout的拷贝，作为程序的stderr，#L112](.//10_examples_file/file_stdin.sh#L112)
		+ [而程序原本要输出到stdout的内容，依然是对接在stdout原身上的，#L113](.//10_examples_file/file_stdin.sh#L113)
		+ [因此第二步重定向stdout，对stdout的拷贝不产生任何影响#L114](.//10_examples_file/file_stdin.sh#L114)
	- [file_stdout.sh](.//10_examples_file/file_stdout.sh)
		+ [重定向命令列表如下：#L11](.//10_examples_file/file_stdout.sh#L11)
		+ [命令					说明#L14](.//10_examples_file/file_stdout.sh#L14)
		+ [command > file	将输出重定向到 file。#L16](.//10_examples_file/file_stdout.sh#L16)
		+ [command < file	将输入重定向到 file。#L17](.//10_examples_file/file_stdout.sh#L17)
		+ [command >> file	将输出以追加的方式重定向到 file。#L18](.//10_examples_file/file_stdout.sh#L18)
		+ [n > file			将文件描述符为 n 的文件重定向到 file。#L19](.//10_examples_file/file_stdout.sh#L19)
		+ [n >> file			将文件描述符为 n 的文件以追加的方式重定向到 file。#L20](.//10_examples_file/file_stdout.sh#L20)
		+ [n >& m			将输出文件 m 和 n 合并。#L21](.//10_examples_file/file_stdout.sh#L21)
		+ [n <& m			将输入文件 m 和 n 合并。#L22](.//10_examples_file/file_stdout.sh#L22)
		+ [<< tag			将开始标记 tag 和结束标记 tag 之间的内容作为输入。#L23](.//10_examples_file/file_stdout.sh#L23)
		+ [需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。#L28](.//10_examples_file/file_stdout.sh#L28)
		+ [重定向深入讲解#L30](.//10_examples_file/file_stdout.sh#L30)
		+ [一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：#L32](.//10_examples_file/file_stdout.sh#L32)
		+ [标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。#L34](.//10_examples_file/file_stdout.sh#L34)
		+ [标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。#L35](.//10_examples_file/file_stdout.sh#L35)
		+ [标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。#L36](.//10_examples_file/file_stdout.sh#L36)
		+ [默认情况下，command > file 将 stdout 重定向到 file，command < file 将stdin 重定向到 file。#L37](.//10_examples_file/file_stdout.sh#L37)
		+ [输出重定向#L43](.//10_examples_file/file_stdout.sh#L43)
		+ [重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:#L45](.//10_examples_file/file_stdout.sh#L45)
		+ [command1 > file1#L47](.//10_examples_file/file_stdout.sh#L47)
		+ [上面这个命令执行command1然后将输出的内容存入file1。#L48](.//10_examples_file/file_stdout.sh#L48)
		+ [注意：任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用>>操作符。#L50](.//10_examples_file/file_stdout.sh#L50)
		+ [实例#L55](.//10_examples_file/file_stdout.sh#L55)
		+ [执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):#L57](.//10_examples_file/file_stdout.sh#L57)
		+ [执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。#L61](.//10_examples_file/file_stdout.sh#L61)
		+ [你可以使用 cat 命令查看文件内容：#L64](.//10_examples_file/file_stdout.sh#L64)
		+ [输出重定向会覆盖文件内容，请看下面的例子：#L72](.//10_examples_file/file_stdout.sh#L72)
		+ [Halloween#L77](.//10_examples_file/file_stdout.sh#L77)
		+ [如果不希望文件内容被覆盖，可以使用 >> 追加到文件末尾，例如：#L79](.//10_examples_file/file_stdout.sh#L79)
		+ [Halloween#L83](.//10_examples_file/file_stdout.sh#L83)
		+ [hallo world！#L84](.//10_examples_file/file_stdout.sh#L84)
+ [/11_examples_import](.//11_examples_import)
	- [import_file.sh](.//11_examples_import/import_file.sh)
		+ [. filename#L10](.//11_examples_import/import_file.sh#L10)
		+ [注意点号(.)和文件名中间有一空格#L11](.//11_examples_import/import_file.sh#L11)
		+ [或#L13](.//11_examples_import/import_file.sh#L13)
		+ [source filename#L14](.//11_examples_import/import_file.sh#L14)
		+ [实例#L19](.//11_examples_import/import_file.sh#L19)
		+ [创建两个 shell 脚本文件。#L22](.//11_examples_import/import_file.sh#L22)
		+ [test1.sh 代码如下：#L24](.//11_examples_import/import_file.sh#L24)
		+ [url="http://www.baidu.com"#L25](.//11_examples_import/import_file.sh#L25)
		+ [test2.sh 代码如下：#L28](.//11_examples_import/import_file.sh#L28)
		+ [使用  “.” 号来引用 test1.sh 文件#L30](.//11_examples_import/import_file.sh#L30)
		+ [或者使用以下包含文件代码#L33](.//11_examples_import/import_file.sh#L33)
		+ [source ./test1.sh#L34](.//11_examples_import/import_file.sh#L34)
		+ [接下来，我们为 test2.sh 添加可执行权限并执行：#L38](.//11_examples_import/import_file.sh#L38)
		+ [$ chmod +x test2.sh#L39](.//11_examples_import/import_file.sh#L39)
		+ [$ ./test2.sh#L40](.//11_examples_import/import_file.sh#L40)
		+ [官网地址：http://www.runoob.com#L42](.//11_examples_import/import_file.sh#L42)
		+ [注：被包含的文件 test1.sh 不需要可执行权限。#L43](.//11_examples_import/import_file.sh#L43)
	- [test1.sh](.//11_examples_import/test1.sh)
+ [/12_examples_debug](.//12_examples_debug)
	- [shell_debug.sh](.//12_examples_debug/shell_debug.sh)
		+ [启用#L10](.//12_examples_debug/shell_debug.sh#L10)
		+ [禁用#L14](.//12_examples_debug/shell_debug.sh#L14)
		+ [shell —— debug 脚本调试#L18](.//12_examples_debug/shell_debug.sh#L18)
		+ [#L23](.//12_examples_debug/shell_debug.sh#L23)
		+ [bash -n scriptname#L24](.//12_examples_debug/shell_debug.sh#L24)
		+ [bash -v scriptname#L25](.//12_examples_debug/shell_debug.sh#L25)
		+ [bash -x scriptname#L26](.//12_examples_debug/shell_debug.sh#L26)
		+ [set -euo pipefail#L28](.//12_examples_debug/shell_debug.sh#L28)
		+ [trap "echo 'error: Script failed: see failed command above'" ERR#L29](.//12_examples_debug/shell_debug.sh#L29)
		+ [一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息#L30](.//12_examples_debug/shell_debug.sh#L30)
		+ [#L31](.//12_examples_debug/shell_debug.sh#L31)
		+ [如果管道中的任何命令失败，则将使用该返回码作为整个管道的返回码 (echo $?)。#L35](.//12_examples_debug/shell_debug.sh#L35)
		+ [默认情况下，管道的返回代码是最后一个命令的代码 - 即使成功。#L36](.//12_examples_debug/shell_debug.sh#L36)
		+ [示例1：检查脚本的语法错误#L43](.//12_examples_debug/shell_debug.sh#L43)
		+ [output:#L47](.//12_examples_debug/shell_debug.sh#L47)
		+ [#L49](.//12_examples_debug/shell_debug.sh#L49)
		+ [示例2：执行脚本并输出脚本#L53](.//12_examples_debug/shell_debug.sh#L53)
		+ [output:#L58](.//12_examples_debug/shell_debug.sh#L58)
		+ [#L60](.//12_examples_debug/shell_debug.sh#L60)
		+ [示例3：在命令行处理之后输出命令#L65](.//12_examples_debug/shell_debug.sh#L65)
		+ [output:#L70](.//12_examples_debug/shell_debug.sh#L70)
		+ [#L72](.//12_examples_debug/shell_debug.sh#L72)
		+ [示例：期望具有非零退出状态的命令#L76](.//12_examples_debug/shell_debug.sh#L76)
		+ [当你想运行一个失败的命令，或者你知道有一个非零的退出代码时会发生什么？#L78](.//12_examples_debug/shell_debug.sh#L78)
		+ [你不希望它停止你的脚本，因为这实际上是正确的行为。#L79](.//12_examples_debug/shell_debug.sh#L79)
		+ [在严格模式下，下一行中止并出现错误：#L82](.//12_examples_debug/shell_debug.sh#L82)
		+ [但是下面的方式将更好：#L85](.//12_examples_debug/shell_debug.sh#L85)
		+ [output:#L89](.//12_examples_debug/shell_debug.sh#L89)
		+ [0#L91](.//12_examples_debug/shell_debug.sh#L91)
		+ [示例：知道一个命令的返回值，即使该返回值不为零，该怎么办呢？#L95](.//12_examples_debug/shell_debug.sh#L95)
		+ [然后，您可以暂时禁用立即退出选项: set +e#L96](.//12_examples_debug/shell_debug.sh#L96)
		+ [当一行或多行匹配时，grep的返回码为0;#L103](.//12_examples_debug/shell_debug.sh#L103)
		+ [1 如果没有行匹配; 和2在一个错误。#L104](.//12_examples_debug/shell_debug.sh#L104)
		+ [这种模式让我们区分它们。#L105](.//12_examples_debug/shell_debug.sh#L105)
		+ [output:#L110](.//12_examples_debug/shell_debug.sh#L110)
		+ [#L112](.//12_examples_debug/shell_debug.sh#L112)
+ [/13_examples_settings](.//13_examples_settings)
	- [ifs_test.sh](.//13_examples_settings/ifs_test.sh)
		+ [示例：如果将此调用为#L13](.//13_examples_settings/ifs_test.sh#L13)
		+ [sh ifs_test.sh notes todo-list 'My Resume.doc'，#L14](.//13_examples_settings/ifs_test.sh#L14)
		+ [然后使用默认的IFS值，则第三个参数将被错误解析为两个单独的文件名为“My”和“Resume.doc”。#L15](.//13_examples_settings/ifs_test.sh#L15)
		+ [当实际上它是一个文件，它有一个空间，名为“我的Resume.doc”。#L16](.//13_examples_settings/ifs_test.sh#L16)
		+ [将IFS设置为$'\n\t'意味着单词拆分只会发生在换行符和制表符中。#L18](.//13_examples_settings/ifs_test.sh#L18)
		+ [IFS=$'\n\t'#L19](.//13_examples_settings/ifs_test.sh#L19)
		+ [output:#L27](.//13_examples_settings/ifs_test.sh#L27)
		+ [$ ./ifs_test.sh notes todo-list 'My Resume.doc'#L29](.//13_examples_settings/ifs_test.sh#L29)
		+ [doing something with file: notes#L30](.//13_examples_settings/ifs_test.sh#L30)
		+ [doing something with file: todo-list#L31](.//13_examples_settings/ifs_test.sh#L31)
		+ [doing something with file: My#L32](.//13_examples_settings/ifs_test.sh#L32)
		+ [doing something with file: Resume.doc#L33](.//13_examples_settings/ifs_test.sh#L33)
		+ [IFS=$'\n\t'#L37](.//13_examples_settings/ifs_test.sh#L37)
		+ [output:#L38](.//13_examples_settings/ifs_test.sh#L38)
		+ [$ ./ifs_test.sh notes todo-list 'My Resume.doc'#L40](.//13_examples_settings/ifs_test.sh#L40)
		+ [doing something with file: notes#L41](.//13_examples_settings/ifs_test.sh#L41)
		+ [doing something with file: todo-list#L42](.//13_examples_settings/ifs_test.sh#L42)
		+ [doing something with file: My Resume.doc#L43](.//13_examples_settings/ifs_test.sh#L43)
	- [settings_ifs.sh](.//13_examples_settings/settings_ifs.sh)
		+ [设置IFS —— 设置分词的方式#L11](.//13_examples_settings/settings_ifs.sh#L11)
		+ [设置默认是分词分割规则#L13](.//13_examples_settings/settings_ifs.sh#L13)
		+ [示例：使用空格分词，items被分割成3个词#L20](.//13_examples_settings/settings_ifs.sh#L20)
		+ [output:#L29](.//13_examples_settings/settings_ifs.sh#L29)
		+ [a#L31](.//13_examples_settings/settings_ifs.sh#L31)
		+ [b#L32](.//13_examples_settings/settings_ifs.sh#L32)
		+ [c#L33](.//13_examples_settings/settings_ifs.sh#L33)
		+ [示例：使用换行分词，items被认为是一个单词#L38](.//13_examples_settings/settings_ifs.sh#L38)
		+ [output:#L46](.//13_examples_settings/settings_ifs.sh#L46)
		+ [a b c#L48](.//13_examples_settings/settings_ifs.sh#L48)
		+ [示例：数组设置IFS分词或默认情况效果都是一样的#L54](.//13_examples_settings/settings_ifs.sh#L54)
		+ [output:#L75](.//13_examples_settings/settings_ifs.sh#L75)
		+ [With default IFS value...#L77](.//13_examples_settings/settings_ifs.sh#L77)
		+ [Aaron Maxwell#L78](.//13_examples_settings/settings_ifs.sh#L78)
		+ [Wayne Gretzky#L79](.//13_examples_settings/settings_ifs.sh#L79)
		+ [David Beckham#L80](.//13_examples_settings/settings_ifs.sh#L80)
		+ [Anderson da Silva#L81](.//13_examples_settings/settings_ifs.sh#L81)
		+ [With strict-mode IFS value...#L83](.//13_examples_settings/settings_ifs.sh#L83)
		+ [Aaron Maxwell#L84](.//13_examples_settings/settings_ifs.sh#L84)
		+ [Wayne Gretzky#L85](.//13_examples_settings/settings_ifs.sh#L85)
		+ [David Beckham#L86](.//13_examples_settings/settings_ifs.sh#L86)
		+ [Anderson da Silva#L87](.//13_examples_settings/settings_ifs.sh#L87)
+ [/14_examples_commons](.//14_examples_commons)
	- [check-args.sh](.//14_examples_commons/check-args.sh)
		+ [在严格模式下，您需要将此用于所有位置参数引用#L11](.//14_examples_commons/check-args.sh#L11)
		+ [output:#L27](.//14_examples_commons/check-args.sh#L27)
		+ [$ bash check-args.sh#L29](.//14_examples_commons/check-args.sh#L29)
		+ [usage: check-args.sh NAME#L30](.//14_examples_commons/check-args.sh#L30)
		+ [$ bash check-args.sh haha#L32](.//14_examples_commons/check-args.sh#L32)
		+ [Hello, haha#L33](.//14_examples_commons/check-args.sh#L33)
	- [force-clean.sh](.//14_examples_commons/force-clean.sh)
		+ [clean —— 在脚本退出的时候强制清理资源#L11](.//14_examples_commons/force-clean.sh#L11)
		+ [定义了一个执行清理或释放资源的bash函数，然后在退出时注册要自动调用的函数。#L13](.//14_examples_commons/force-clean.sh#L13)
		+ [示例：以下是如何使用退出时来强大地清理临时目录：#L20](.//14_examples_commons/force-clean.sh#L20)
		+ [现在脚本可以在“$scratch”目录中写入文件。#L22](.//14_examples_commons/force-clean.sh#L22)
		+ [退出时会自动删除，无论是否出错，或正常完成。#L23](.//14_examples_commons/force-clean.sh#L23)
		+ [生成一个临时目录#L25](.//14_examples_commons/force-clean.sh#L25)
		+ [output:#L33](.//14_examples_commons/force-clean.sh#L33)
		+ [#L35](.//14_examples_commons/force-clean.sh#L35)
	- [strong-bash.sh](.//14_examples_commons/strong-bash.sh)
		+ [强壮健康的bash脚本应该是怎么样的？#L11](.//14_examples_commons/strong-bash.sh#L11)
		+ [1、提供--help标记#L13](.//14_examples_commons/strong-bash.sh#L13)
		+ [2、检查所有命令的可用性#L14](.//14_examples_commons/strong-bash.sh#L14)
		+ [3、独立于当前工作目录#L15](.//14_examples_commons/strong-bash.sh#L15)
		+ [4、如何读取输入：环境变量 vs. 标记#L16](.//14_examples_commons/strong-bash.sh#L16)
		+ [5、打印对系统执行的所有操作#L17](.//14_examples_commons/strong-bash.sh#L17)
		+ [6、如果有必要，提供--silent选项#L18](.//14_examples_commons/strong-bash.sh#L18)
		+ [7、重新开启显示#L19](.//14_examples_commons/strong-bash.sh#L19)
		+ [8、用动画的方式显示进度#L20](.//14_examples_commons/strong-bash.sh#L20)
		+ [9、用颜色编码输出#L21](.//14_examples_commons/strong-bash.sh#L21)
		+ [10、出现错误立即退出脚本#L22](.//14_examples_commons/strong-bash.sh#L22)
		+ [11、自己执行清理工作#L23](.//14_examples_commons/strong-bash.sh#L23)
		+ [12、在退出时使用不同的错误码#L24](.//14_examples_commons/strong-bash.sh#L24)
		+ [13、在结束时打印一个新行#L25](.//14_examples_commons/strong-bash.sh#L25)
		+ [示例：提供 --help 标记#L32](.//14_examples_commons/strong-bash.sh#L32)
		+ [提供help选项，为脚本提供帮助文档，也方便在日后使用或修改文本作为依据#L34](.//14_examples_commons/strong-bash.sh#L34)
		+ [output:#L45](.//14_examples_commons/strong-bash.sh#L45)
		+ [$ sh strong-bash.sh --help#L47](.//14_examples_commons/strong-bash.sh#L47)
		+ [strong-bash.sh --help#L48](.//14_examples_commons/strong-bash.sh#L48)
		+ [强壮的bash脚本...#L49](.//14_examples_commons/strong-bash.sh#L49)
		+ [usage: bash +x strong-bash.sh#L50](.//14_examples_commons/strong-bash.sh#L50)
		+ [示例：检查所有命令的可用性#L54](.//14_examples_commons/strong-bash.sh#L54)
		+ [检查命令的可用性，在不可用的情况下，给予友好提示#L56](.//14_examples_commons/strong-bash.sh#L56)
		+ [output:#L72](.//14_examples_commons/strong-bash.sh#L72)
		+ [#L74](.//14_examples_commons/strong-bash.sh#L74)
		+ [示例：独立于当前工作目录#L79](.//14_examples_commons/strong-bash.sh#L79)
		+ [提供独立的工作目录，能让脚本在任何地方运行，在脚本中坚持使用“绝对路径”#L81](.//14_examples_commons/strong-bash.sh#L81)
		+ [可以使用dirname $0引用脚本的当前路径：#L83](.//14_examples_commons/strong-bash.sh#L83)
		+ [output:#L91](.//14_examples_commons/strong-bash.sh#L91)
		+ [#L93](.//14_examples_commons/strong-bash.sh#L93)
		+ [示例：如何读取输入：环境变量 vs. 标记#L98](.//14_examples_commons/strong-bash.sh#L98)
		+ [脚本接收参数的方式有3种，环境变量、选项标记、动态输入(read)#L100](.//14_examples_commons/strong-bash.sh#L100)
		+ [根据经验，对于不影响脚本行为的值，可以使用环境变量，#L101](.//14_examples_commons/strong-bash.sh#L101)
		+ [而对于可能触发脚本不同流程的值，可以使用脚本参数。#L102](.//14_examples_commons/strong-bash.sh#L102)
		+ [#L103](.//14_examples_commons/strong-bash.sh#L103)
		+ [如果参数较多，可以将固定的参数从环境变量读取，变化频繁的使用参数读取#L104](.//14_examples_commons/strong-bash.sh#L104)
		+ [不影响脚本行为的变量可能是访问令牌和 ID、路径等配置#L107](.//14_examples_commons/strong-bash.sh#L107)
		+ [运行脚本读取 变量 ${ACCESS_TOKEN}#L110](.//14_examples_commons/strong-bash.sh#L110)
		+ [./xxx.sh#L111](.//14_examples_commons/strong-bash.sh#L111)
		+ [或者 通过临时变量的形式#L113](.//14_examples_commons/strong-bash.sh#L113)
		+ [INSTANCE_COUNT=400 ASYNC=true ./xxx.sh#L114](.//14_examples_commons/strong-bash.sh#L114)
		+ [对于业务流程上的参数，通过标记的形式读取#L117](.//14_examples_commons/strong-bash.sh#L117)
		+ [./xxx.sh --async --instance-count 400#L119](.//14_examples_commons/strong-bash.sh#L119)
		+ [或者 动态变量参数#L121](.//14_examples_commons/strong-bash.sh#L121)
		+ [./xxx.sh --async true --token 'xxxxxxxxxxx'#L122](.//14_examples_commons/strong-bash.sh#L122)
		+ [output:#L126](.//14_examples_commons/strong-bash.sh#L126)
		+ [#L128](.//14_examples_commons/strong-bash.sh#L128)
		+ [示例：打印对系统执行的所有操作，输出操作日志#L133](.//14_examples_commons/strong-bash.sh#L133)
		+ [脚本通常会对系统执行有状态的更改。不过，由于我们不知道用户何时会向发送SIGINT，#L135](.//14_examples_commons/strong-bash.sh#L135)
		+ [也不知道脚本错误何时可能导致脚本意外终止，因此很有必要将正在做的事情打印在终端上，#L136](.//14_examples_commons/strong-bash.sh#L136)
		+ [这样用户就可以在不去查看脚本的情况下回溯这些步骤#L137](.//14_examples_commons/strong-bash.sh#L137)
		+ [对于没有输出日志的脚本可以试试以下方式运行：#L139](.//14_examples_commons/strong-bash.sh#L139)
		+ [将会在命令执行前输出它们#L140](.//14_examples_commons/strong-bash.sh#L140)
		+ [bash -v xxx.sh#L141](.//14_examples_commons/strong-bash.sh#L141)
		+ [将会在命令行处理之后输出命令#L142](.//14_examples_commons/strong-bash.sh#L142)
		+ [bash -x xxx.sh#L143](.//14_examples_commons/strong-bash.sh#L143)
		+ [output:#L157](.//14_examples_commons/strong-bash.sh#L157)
		+ [#L159](.//14_examples_commons/strong-bash.sh#L159)
		+ [示例：在必要时提供 --silent 选项#L164](.//14_examples_commons/strong-bash.sh#L164)
		+ [有些脚本是为了将其输出传给其他脚本。虽说脚本都应该能够单独运行，#L166](.//14_examples_commons/strong-bash.sh#L166)
		+ [不过有时候也有必要让它们把输出结果传给另一个脚本。#L167](.//14_examples_commons/strong-bash.sh#L167)
		+ [可以利用stty -echo来实现--silent标记：#L168](.//14_examples_commons/strong-bash.sh#L168)
		+ [output:#L186](.//14_examples_commons/strong-bash.sh#L186)
		+ [#L188](.//14_examples_commons/strong-bash.sh#L188)
		+ [示例：重新开启显示#L193](.//14_examples_commons/strong-bash.sh#L193)
		+ [在使用stty -echo关闭脚本显示之后，如果发生致命错误，脚本将终止，#L195](.//14_examples_commons/strong-bash.sh#L195)
		+ [而且不会恢复终端输出，这样对用户来说是没有意义的。#L196](.//14_examples_commons/strong-bash.sh#L196)
		+ [可以使用trap来捕捉SIGINT和其他操作系统级别的信号，#L197](.//14_examples_commons/strong-bash.sh#L197)
		+ [然后使用stty echo打开终端显示：#L198](.//14_examples_commons/strong-bash.sh#L198)
		+ [output:#L215](.//14_examples_commons/strong-bash.sh#L215)
		+ [#L217](.//14_examples_commons/strong-bash.sh#L217)
		+ [示例：用动画的方式显示进度#L222](.//14_examples_commons/strong-bash.sh#L222)
		+ [有些命令需要运行很长时间，并非所有脚本都提供了进度条。#L224](.//14_examples_commons/strong-bash.sh#L224)
		+ [在用户等待异步任务完成时，可以通过一些方式告诉他们脚本仍在运行。#L225](.//14_examples_commons/strong-bash.sh#L225)
		+ [比如在while循环中打印一些信息：#L226](.//14_examples_commons/strong-bash.sh#L226)
		+ [http://mywiki.wooledge.org/BashFAQ/034#L227](.//14_examples_commons/strong-bash.sh#L227)
		+ [output:#L246](.//14_examples_commons/strong-bash.sh#L246)
		+ [#L248](.//14_examples_commons/strong-bash.sh#L248)
		+ [示例：用颜色编码输出#L252](.//14_examples_commons/strong-bash.sh#L252)
		+ [在脚本中调用其他二进制文件或脚本时，对它们的输出进行颜色编码，#L253](.//14_examples_commons/strong-bash.sh#L253)
		+ [这样就可以知道哪个输出来自哪个脚本或二进制文件，查找日志就更加方便。#L254](.//14_examples_commons/strong-bash.sh#L254)
		+ [理想情况下，脚本应该输出白色（默认的，前台进程），#L256](.//14_examples_commons/strong-bash.sh#L256)
		+ [子进程应该使用灰色（通常不需要，除非出现错误），#L257](.//14_examples_commons/strong-bash.sh#L257)
		+ [使用绿色表示成功，红色表示失败，黄色表示警告。#L258](.//14_examples_commons/strong-bash.sh#L258)
		+ [颜色对照表：https://misc.flogisoft.com/bash/tip_colors_and_formatting#L259](.//14_examples_commons/strong-bash.sh#L259)
		+ [output:#L273](.//14_examples_commons/strong-bash.sh#L273)
		+ [#L275](.//14_examples_commons/strong-bash.sh#L275)
		+ [示例：出现错误立即退出脚本#L281](.//14_examples_commons/strong-bash.sh#L281)
		+ [set -e表示从当前位置开始，如果出现任何错误都将触发EXIT。#L282](.//14_examples_commons/strong-bash.sh#L282)
		+ [相反，set +e表示不管出现任何错误继续执行脚本。#L283](.//14_examples_commons/strong-bash.sh#L283)
		+ [#L284](.//14_examples_commons/strong-bash.sh#L284)
		+ [如果脚本是有状态的（每个后续步骤都依赖前一个步骤），那么请使用set -e，#L285](.//14_examples_commons/strong-bash.sh#L285)
		+ [在脚本出现错误时立即退出脚本。如果要求所有命令都要执行完（很少会这样），那么就使用set +e。#L286](.//14_examples_commons/strong-bash.sh#L286)
		+ [output:#L302](.//14_examples_commons/strong-bash.sh#L302)
		+ [#L304](.//14_examples_commons/strong-bash.sh#L304)
		+ [示例：自己执行清理工作#L310](.//14_examples_commons/strong-bash.sh#L310)
		+ [大多数脚本在出现错误时不会执行清理工作，能够做好这方面工作的脚本实属罕见，#L311](.//14_examples_commons/strong-bash.sh#L311)
		+ [但这样做其实很有用，还可以省下不少时间。#L312](.//14_examples_commons/strong-bash.sh#L312)
		+ [前面已经给出过示例，让stty恢复正常，并借助trap命令来执行清理工作#L313](.//14_examples_commons/strong-bash.sh#L313)
		+ [output:#L330](.//14_examples_commons/strong-bash.sh#L330)
		+ [#L332](.//14_examples_commons/strong-bash.sh#L332)
		+ [示例：在退出时使用不同的错误码#L337](.//14_examples_commons/strong-bash.sh#L337)
		+ [在绝大多数 shell 脚本中，exit 0 表示执行成功，exit 1 表示发生错误。#L338](.//14_examples_commons/strong-bash.sh#L338)
		+ [对错误与错误码进行一对一的映射，这样有助于脚本调试。#L339](.//14_examples_commons/strong-bash.sh#L339)
		+ [#L340](.//14_examples_commons/strong-bash.sh#L340)
		+ [这样做有另一个额外的好处，就是其他脚本在调用你的脚本时，可以根据错误码来判断发生了什么错误。#L341](.//14_examples_commons/strong-bash.sh#L341)
		+ [output:#L356](.//14_examples_commons/strong-bash.sh#L356)
		+ [#L358](.//14_examples_commons/strong-bash.sh#L358)
		+ [示例：在结束时打印一个新行#L363](.//14_examples_commons/strong-bash.sh#L363)
		+ [如果你有在遵循脚本的最佳实践，那么可能会使用printf代替echo（它在不同系统中的行为有所差别）。#L364](.//14_examples_commons/strong-bash.sh#L364)
		+ [问题是printf在命令结束后不会自动添加一个新行.#L365](.//14_examples_commons/strong-bash.sh#L365)
		+ [output:#L372](.//14_examples_commons/strong-bash.sh#L372)
		+ [#L374](.//14_examples_commons/strong-bash.sh#L374)
+ [](./)
	- [comment.sh](.//comment.sh)
		+ [#L11](.//comment.sh#L11)
		+ [#L13](.//comment.sh#L13)
		+ [示例：#L20](.//comment.sh#L20)
		+ [output:#L23](.//comment.sh#L23)
		+ [#L25](.//comment.sh#L25)
		+ [示例：#L29](.//comment.sh#L29)
		+ [output:#L33](.//comment.sh#L33)
		+ [#L35](.//comment.sh#L35)
