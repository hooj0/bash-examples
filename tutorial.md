# .idea/inspectionProfiles 
[**.idea/inspectionProfiles**](./.idea/inspectionProfiles)
# .idea 
[**.idea**](./.idea)
# 01_example_started 
[**01_example_started**](./01_example_started)
## hello_world 
[`hello_world`](./01_example_started/hello_world.sh)

```bash 
# ==========================================================================
# 运行 Shell 脚本有两种方法：
# ==========================================================================

# 1、作为可执行程序
# --------------------------------------------------------------------------
# 将上面的代码保存为 hello_world.sh，并 cd 到相应目录：
#
# chmod +x ./hello_world.sh  #使脚本具有执行权限
# ./hello_world.sh  #执行脚本
#
# --------------------------------------------------------------------------
# 注意，一定要写成 ./hello_world.sh，而不是 hello_world.sh，运行其它二进制的程序也一样，
# 直接写 hello_world.sh，linux 系统会去 PATH 里寻找有没有叫 hello_world.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，
# 你的当前目录通常不在 PATH 里，所以写成 hello_world.sh 是会找不到命令的，要用 ./hello_world.sh 告诉系统说，就在当前目录找。
# --------------------------------------------------------------------------


# 2、作为解释器参数
# --------------------------------------------------------------------------
# 这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：

# /bin/sh hello_world.sh
# /bin/php hello_world.php

# sh hello_world.sh
# bash hello_world.sh
# --------------------------------------------------------------------------
# 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。
# --------------------------------------------------------------------------




# ==========================================================================
# source、sh、bash、./ 执行脚本的区别是什么？
# ==========================================================================


# 1. source命令用法：
# --------------------------------------------------------------------------
 
```
# 02_examples_variable 
[**02_examples_variable**](./02_examples_variable)
## var_assignment 
[`var_assignment`](./02_examples_variable/var_assignment.sh)

```bash 
r=`expr $a + $b`
echo "result: $r"

r=`expr $a + $b + $r`
echo "result: $r"

r=$[a+b]
echo "result: $r"

let "r=a+b+a"
echo "result: $r"

:${d:= 10} # var:= 不能有空格
echo "result-d: $d"

# 变量运算赋值
# ------------------------------------------------------------------
# bash 里面可以用 (( )) 执行 C 风格的算术表达式
# ------------------------------------------------------------------

var=0
(( var += 1 )) # 这是一种，现在 var 是 1
echo "var: $var"

(( var++ ))    # 这也是一种自增，2
echo "var: $var"

(( var = var * var )) # 怎么来乘法了！var 现在是 4。
echo "var: $var"


let 'var = var / 3'   # 还是只有 bash 才能用的拓展。除法是整数除法，向 0 舍入，1。
echo "var: $var"


# $(( )) 会展开成为这个 C 表达式求值的结果。以前 bash 有个 $[ ] 一样，但是别去用。
var=$((var += 2))    # echo 出 3，var 现在是 3。
echo "var: $var"


var=$((var-1))        # 展开成 var=2，var 现在是……还用说吗，2。
 
```
## var_declare 
[`var_declare`](./02_examples_variable/var_declare.sh)

```bash 
#var$temp="st1" # var=st1: 未找到命令

#####################################################################
# 变量名的命名须遵循如下规则：
#	*、变量名和等号之间不能有空格
#	1、命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
#	2、中间不能有空格，可以使用下划线（_）。
#	3、不能使用标点符号。
#	4、不能使用bash里的关键字（可用help命令查看保留关键字）。

# help

# var1 = "不能有空格"	# var1: 未找到命令
var1="success"
echo "var1: $var1"

var_2="haha"
echo "var_2:" $var_2


# 有效的 Shell 变量名示例如下：

USER="jack"
LD_LIBRARY_PATH="/tmp/lib/"
_var=2
var2=3

# 无效的变量命名：
# ?var=123
# user*name=runoob



#####################################################################
# 除了显式地直接赋值，还可以用语句给变量赋值，如：

# 将 /etc 下目录的文件名循环出来。
for file in `ls /etc`; 
	do echo $file;
done

 
```
## var_delete 
[`var_delete`](./02_examples_variable/var_delete.sh)

```bash 
#
#	变量被删除后不能再次使用。
#	unset 命令不能删除只读变量。
##############################################################



# 实例
var_tmp="remove var"
unset var_tmp

echo $var_tmp

#以上实例执行将没有任何输出。
 
```
## var_readonly 
[`var_readonly`](./02_examples_variable/var_readonly.sh)

```bash 
readonly myUrl

# 下面的例子尝试更改只读变量，结果报错：
myUrl="http://www.runoob.com"

# 运行脚本，结果如下：
# /bin/sh: NAME: This variable is read only.
 
```
## var_scope 
[`var_scope`](./02_examples_variable/var_scope.sh)

```bash 
#	2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
#	3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

 
```
## var_ternary_op 
[`var_ternary_op`](./02_examples_variable/var_ternary_op.sh)

```bash 
${varname:+word}    # 如果 varname 存在而且不为 null，返回 word，否则返回 null
${varname:offset:length}    # 它返回 $varname 的子字符串，从 offset 处开始，长度为 length 
```
## var_used 
[`var_used`](./02_examples_variable/var_used.sh)

```bash 

your_name="qinjx"
echo $your_name
echo ${your_name}

# 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：
for skill in Ada Coffe Action Java; do
    echo "I am good at ${skill}Script"
done

# 如果不给skill变量加花括号，写成echo "I am good at $skillScript"，
# 解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。

# 推荐给所有变量加上花括号，这是个好的编程习惯。

# 已定义的变量，可以被重新定义，如：
your_name="tom"
echo $your_name

your_name="alibaba"
echo $your_name
# 这样写是合法的，但注意，第二次赋值的时候不能写$your_name="alibaba"，使用变量的时候才加美元符（$）。 
```
# 03_examples_data_type 
[**03_examples_data_type**](./03_examples_data_type)
## type_arrays 
[`type_arrays`](./03_examples_data_type/type_arrays.sh)

```bash 
# 获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。
#########################################################################

# 定义数组
#-------------------------------------------------------------------------
# 在Shell中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为：
#
# 数组名=(值1 值2 ... 值n)
#-------------------------------------------------------------------------


# 例如：
#-------------------------------------------------------------------------
array_name=(value0 value1 value2 value3)
echo "array: ${array_name[@]}"

# 或者
array_name=(
 	a
 	b
 	c
 	d
)
echo "array: ${array_name[@]}"

# 或者
array=([2]=a [0]=b [1]=c)
echo "array: ${array[@]}"

# 还可以单独定义数组的各个分量：
#-------------------------------------------------------------------------
# 可以不使用连续的下标，而且下标的范围没有限制。
array_name[0]=v0
array_name[1]=v1
array_name[n]=vn

echo
echo "array[@]: ${array_name[@]}"
echo
echo "array[0]: ${array_name[0]}"
echo "array[1]: ${array_name[1]}"
 
```
## type_strings 
[`type_strings`](./03_examples_data_type/type_strings.sh)

```bash 
#
# 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
# 单引号字串中不能出现单引号（对单引号使用转义符也不行）。
#-----------------------------------
# 双引号的优点：
#
# 双引号里可以有变量
# 双引号里可以出现转义字符
#----------------------------------------------------------------------


# 单引号
# ---------------------------------------------------------------------
str='this is a string'
echo $str

# 原样输出，表达式和转义字符无效
# ---------------------------------------------------------------------
str='this is a string $str \"s'
echo $str

# 双引号
# ---------------------------------------------------------------------
your_name='jack'
str="Hello, I know you are \"$your_name\"! \n line" # 并沒有換行
echo $str

# 拼接字符串
# ---------------------------------------------------------------------
your_name="jason"
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"

echo $greeting $greeting_1

# 获取字符串长度
# ---------------------------------------------------------------------
string="abcd"
echo ${#string} # 输出 4

string="hello,everyone my name is xiaoming"
 
```
## type_strings_substr 
[`type_strings_substr`](./03_examples_data_type/type_strings_substr.sh)

```bash 
# 	一个 # 表示从左边删除到第一个指定的字符；
#	两个 # 表示从左边删除到最后一个指定的字符。

# -------------------------------------------------------------
# 	%、%% 表示从右边开始删除。
# -------------------------------------------------------------
#	一个 % 表示从右边删除到第一个指定的字符；
#	两个 % 表示从左边删除到最后一个指定的字符。

# 删除包括了指定的字符本身。
# -------------------------------------------------------------

# 假设有变量
var=http://www.aaa.com/123.htm



# 1. # 号截取，删除左边字符(第一个字符开始)，保留右边字符。
# ==============================================================
# 其中 var 是变量名，# 号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符

echo ${var#*//} # 结果是 ：www.aaa.com/123.htm



# 2. ## 号截取，删除左边字符（最后一个字符开始），保留右边字符。
# ==============================================================
# #*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符

echo ${var##*/} # 结果是 123.htm




# 3. %号截取，删除右边字符，保留左边字符
# ==============================================================
# %/* 表示从右边开始，删除第一个 / 号及右边的字符

echo ${var%/*} # 结果是：http://www.aaa.com


 
```
# 04_examples_args 
[**04_examples_args**](./04_examples_args)
## args_file 
[`args_file`](./04_examples_args/args_file.sh)

```bash 

# =================================================================
#		脚本文件选项参数的遍历与使用
# =================================================================
# 在使用脚本执行的时候，有时候需要传入动态参数调整脚本的运行流程。
# 通过遍历参数列表，判断参数的选择和值，来进入不同的流程。
# -----------------------------------------------------------------




# =================================================================
#	 示例：遍历参数列表，根据不同的选项执行不同的流程
# =================================================================
echo "传入参数：$@"
echo "第一个参数：${1##[--,-]}"
# 只有当第一个参数，带有 -- 或 - 的选项参数时，才进入循环
while [ "$1" != "${1##[--,-]}" ]; do
	case $1 in
		-D|--description)
			echo "description选项的参数就是$2"
			shift 2
		;;
	      -A|--author)
			echo "author选项的参数就是$2"
			shift 2
		 ;;
	     *)
			echo "使用该脚本时，虽然使用了选项，但是脚本不支持的，都匹配 *"
			echo "在这里就可以提示用户：脚本的使用方法，如：usage | help"
			shift 2
		;;
      esac
done
printf "\n\n"


# output:
#------------------------------------------------------------------
# $ ./args_file.sh -D hello -D world -A hoojo -s 123
# 传入参数：-D hello -D world -A hoojo -s 123
 
```
## args_input 
[`args_input`](./04_examples_args/args_input.sh)

```bash 
#-----------------------------------------------------------------------


# 以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名：

echo "Shell 传递参数实例！";
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";

# 为脚本设置可执行权限，并执行脚本，输出结果如下所示：
#-----------------------------------------------------------------------
#	$ chmod +x args_input.sh 
#	$ ./args_input.sh 1 2 3
#-----------------------------------------------------------------------
# 输出结果
#-----------------------------------------------------------------------
# $ ./args_input.sh 1 2 3
# Shell 传递参数实例！
# 执行的文件名：./args_input.sh
# 第一个参数为：1
# 第二个参数为：2
# 第三个参数为：3 
```
## args_read 
[`args_read`](./04_examples_args/args_read.sh)

```bash 
#==============================================================
#			read 命令用于获取键盘输入信息
#==============================================================


# -------------------------------------------------------------
# 它的语法形式一般是：
# 		read [-options] [variable...]
#		read: 用法: read [-ers] [-a 数组] [-d 分隔符] [-i 缓冲区文字] [-n 读取字符数] [-N 读取字符数] [-p 提示符] [-t 超时] [-u 文件描述符] [名称 ...]
# -------------------------------------------------------------

# 以下实例读取键盘输入的内容并将其赋值给shell变量，为：-p 参数由于设置提示信息：

read -p "input a val:" a    # 获取键盘输入的 a 变量数字
read -p "input b val:" b    # 获取键盘输入的 b 变量数字
r=$[a+b]                    # 计算a+b的结果 赋值给r  不能有空格
echo "result = ${r}"        # 输出显示结果 r
echo `expr $a + $b`


# 测试结果：
# -------------------------------------------------------------
# input a val:1
# input b val:2
# result = 3



# ------------------------------------------------------------------------------------
# read 命令一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔；
#	如果输入的词组个数大于需要的参数个数，则多出的词组将被作为整体为最后一个参数接收。
# ------------------------------------------------------------------------------------

# 测试文件 test.sh 代码如下：
# ------------------------------------------------------------------------------------

read firstStr secondStr
echo "第一个参数:$firstStr; 第二个参数:$secondStr"

# 执行测试：
# ------------------------------------------------------------------------------------
 
```
## args_special 
[`args_special`](./04_examples_args/args_special.sh)

```bash 
#				如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
#	$$			脚本运行的当前进程ID号
#	$!			后台运行的最后一个进程的ID号
#	$@			与$*相同，但是使用时加引号，并在引号中返回每个参数。
#				如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
#	$-			显示Shell使用的当前选项，与set命令功能相同。
#	$?			显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
#--------------------------------------------------------

# 运行脚本，传入参数


echo "参数个数：$#"

echo "显示所有参数：$*"
echo "显示所有参数：$@"

echo "当前进程ID：$$"
echo "最后一个进程Id：$!"

echo "当前选项：$-"
echo "最终状态：$?"


# $* 与 $@ 区别：
#--------------------------------------------------------
# 相同点：都是引用所有参数。
# 不同点：只有在双引号中体现出来。
#	非数组形式：假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），
#	数组的形式：而 "@" 等价于 "1" "2" "3"（传递了三个参数）。
#--------------------------------------------------------
echo "-- \$* 演示 ---"
for i in "$*"; do
    echo $i
done

echo "-- \$@ 演示 ---"
for i in "$@"; do
    echo $i
done  
```
# 05_examples_operator 
[**05_examples_operator**](./05_examples_operator)
## operator_boolean 
[`operator_boolean`](./05_examples_operator/operator_boolean.sh)

```bash 
# !			非运算，表达式为 true 则返回 false，否则返回 true。		[ ! false ] 返回 true。
# -o		或运算，有一个表达式为 true 则返回 true。				[ $a -lt 20 -o $b -gt 100 ] 返回 true。
# -a		与运算，两个表达式都为 true 才返回 true。				[ $a -lt 20 -a $b -gt 100 ] 返回 false。
#---------------------------------------------------------------------
# &&		逻辑的 AND											[[ $a -lt 100 && $b -gt 100 ]] 返回 false
# ||		逻辑的 OR											[[ $a -lt 100 || $b -gt 100 ]] 返回 true
#---------------------------------------------------------------------


#---------------------------------------------------------------------
#				实例
#---------------------------------------------------------------------
# 布尔运算符实例如下：


a=10
b=20

if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a != $b: a 等于 b"
fi

if [ $a -lt 100 -a $b -gt 15 ]
then
   echo "$a 小于 100 且 $b 大于 15 : 返回 true"
else
   echo "$a 小于 100 且 $b 大于 15 : 返回 false"
fi

if [ $a -lt 100 -o $b -gt 100 ]
then
   echo "$a 小于 100 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 100 或 $b 大于 100 : 返回 false"
fi

if [ $a -lt 5 -o $b -gt 100 ]
then
 
```
## operator_file 
[`operator_file`](./05_examples_operator/operator_file.sh)

```bash 
# 操作符			说明																		举例
#------------------------------------------------------------------------------------------------------------
# -b file	检测文件是否是块设备文件，如果是，则返回 true。								[ -b $file ] 返回 false。
# -c file	检测文件是否是字符设备文件，如果是，则返回 true。							[ -c $file ] 返回 false。
# -d file	检测文件是否是目录，如果是，则返回 true。									[ -d $file ] 返回 false。
# -f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。

# -g file	检测文件是否设置了 SGID 位，如果是，则返回 true。							[ -g $file ] 返回 false。
# -k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。					[ -k $file ] 返回 false。
# -p file	检测文件是否是有名管道，如果是，则返回 true。								[ -p $file ] 返回 false。
# -u file	检测文件是否设置了 SUID 位，如果是，则返回 true。							[ -u $file ] 返回 false。

# -r file	检测文件是否可读，如果是，则返回 true。									[ -r $file ] 返回 true。
# -w file	检测文件是否可写，如果是，则返回 true。									[ -w $file ] 返回 true。
# -x file	检测文件是否可执行，如果是，则返回 true。									[ -x $file ] 返回 true。
# -s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。					[ -s $file ] 返回 true。
# -e file	检测文件（包括目录）是否存在，如果是，则返回 true。							[ -e $file ] 返回 true。
#------------------------------------------------------------------------------------------------------------
# file1 -nt file2     # file1 比 file2 更新
# file1 -ot file2     # file1 比 file2 更老
#----------------------------------------------------------------------


#----------------------------------------------------------------------
# 实例
#----------------------------------------------------------------------
# 变量 file 表示文件"./operator_file.sh"，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：
#----------------------------------------------------------------------

file="./operator_file.sh"


if [ -r $file ]
then
   echo "文件可读"
else
   echo "文件不可读"
fi


if [ -w $file ]
 
```
## operator_math 
[`operator_math`](./05_examples_operator/operator_math.sh)

```bash 
# +				加法										`expr $a + $b` 结果为 30。
# -				减法										`expr $a - $b` 结果为 -10。
# *				乘法										`expr $a \* $b` 结果为  200。
# /				除法										`expr $b / $a` 结果为 2。
# %				取余										`expr $b % $a` 结果为 0。
# =				赋值			 							 a=$b 将把变量 b 的值赋给 a。
# ==			相等。用于比较两个数字，相同则返回 true。		[ $a == $b ] 返回 false。
# !=			不相等。用于比较两个数字，不相同则返回 true。	[ $a != $b ] 返回 true。
#------------------------------------------------------------------------
#
# 注意：条件表达式要放在方括号之间，并且要有空格，
# 例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。
#------------------------------------------------------------------------




#------------------------------------------------------------------------
# 实例
#------------------------------------------------------------------------
# 算术运算符实例如下：

a=10
b=20

val=`expr $a + $b`
echo "a + b : $val"

val=`expr $a - $b`
echo "a - b : $val"

val=`expr $a \* $b`
echo "a * b : $val"

val=`expr $b / $a`
echo "b / a : $val"

val=`expr $b % $a`
echo "b % a : $val"

if [ $a == $b ]
 
```
## operator_overview 
[`operator_overview`](./05_examples_operator/operator_overview.sh)

```bash 
#	布尔运算符
#	字符串运算符
#	文件测试运算符
#
# 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。
# expr 是一款表达式计算工具，使用它能完成表达式的求值操作。
#----------------------------------------------------------------


# 例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：
#----------------------------------------------------------------
val=`expr 2 + 2`
echo "两数之和为 : $val"

# 运行实例 »
#----------------------------------------------------------------
#	执行脚本，输出结果如下所示：
#
# 		两数之和为 : 4
#----------------------------------------------------------------

# 两点注意：
#----------------------------------------------------------------

# 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。
# 完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。
#---------------------------------------------------------------- 
```
## operator_relation 
[`operator_relation`](./05_examples_operator/operator_relation.sh)

```bash 
#-----------------------------------------------------------------------
# 运算符		说明														举例
#-----------------------------------------------------------------------
# -eq		检测两个数是否相等，相等返回 true。					[ $a -eq $b ] 返回 false。
# -ne		检测两个数是否不相等，不相等返回 true。				[ $a -ne $b ] 返回 true。
# -gt		检测左边的数是否大于右边的，如果是，则返回 true。		[ $a -gt $b ] 返回 false。
# -lt		检测左边的数是否小于右边的，如果是，则返回 true。		[ $a -lt $b ] 返回 true。
# -ge		检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 返回 false。
# -le		检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 返回 true。
#-----------------------------------------------------------------------
# EQ 就是 EQUAL等于
# NE 就是 NOT EQUAL不等于 
# GT 就是 GREATER THAN大于　 
# LT 就是 LESS THAN小于 
# GE 就是 GREATER THAN OR EQUAL 大于等于 
# LE 就是 LESS THAN OR EQUAL 小于等于
#-----------------------------------------------------------------------
# 1、进行数值比较时，可以使用 [ expression1 OP expression2 ]，OP 可以为 -gt、-lt、-ge、-le、-eq、-ne 
#	也可以使用 ((expression1 OP expression2))，OP 可以为 >、<、>=、<=、==、!=。
#	这几个关系运算符都是测试整数表达式 expression1 和 expression2 之间的大小关系。

# 2、 >、<、==、!= 也可以进行字符串比较。
# 3、进行字符串比较时，== 可以使用 = 替代。
# 4、 == 和 !=进行字符串比较时，可以使用 [ string1 OP string2 ] 或者 [[ string1 OP string2 ]] 的形式。
# 5、 > 和 < 进行字符串比较时，需要使用[[ string1 OP string2 ]] 或者 [ string1 \OP string2 ]。也就是使用 [] 时，> 和 < 需要使用反斜线转义。
#-----------------------------------------------------------------------



#-----------------------------------------------------------------------
# 实例
#-----------------------------------------------------------------------
# 关系运算符实例如下：
#-----------------------------------------------------------------------

a=10
b=20

if (($a == $b)); then
	echo "$a == $b: a = b"
else
 
```
## operator_string 
[`operator_string`](./05_examples_operator/operator_string.sh)

```bash 
#----------------------------------------------------------------------------
# =			检测两个字符串是否相等，相等返回 true。		[ $a = $b ] 返回 false。
# !=		检测两个字符串是否相等，不相等返回 true。		[ $a != $b ] 返回 true。
# -z		检测字符串长度是否为0，为0返回 true。			[ -z $a ] 返回 false。
# -n		检测字符串长度是否不为0，不为0返回 true。		[ -n $a ] 返回 true。
# str		检测字符串是否为空，不为空返回 true。			[ $a ] 返回 true。
#----------------------------------------------------------------------------




#----------------------------------------------------------------------------
# 				实例
#----------------------------------------------------------------------------
# 字符串运算符实例如下：
#----------------------------------------------------------------------------

a="abc"
b="efg"

if [ $a = $b ]
then
   echo "$a = $b : a 等于 b"
else
   echo "$a = $b: a 不等于 b"
fi

if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a != $b: a 等于 b"
fi

if [ -z $a ]
then
   echo "-z $a : 字符串长度为 0"
else
   echo "-z $a : 字符串长度不为 0"
fi

 
```
# 06_examples_output 
[**06_examples_output**](./06_examples_output)
## echo_output 
[`echo_output`](./06_examples_output/echo_output.sh)

```bash 
# 		echo string
#
# 	echo -e 开启转义
# 	echo -n 不换行
#
# 可以使用echo实现更复杂的输出格式控制
#---------------------------------------------------------------------

# echo输出的字符串总结
# ===================================================================
# 				能否引用变量  |  能否引用转移符  	|  能否引用文本格式符(如：换行符、制表符)

# 	单引号  |           否           |             否             |                             否
# 	双引号  |           能           |             能             |                             能
# 	无引号  |           能           |             能             |                             否                          
# ===================================================================





# 1.显示普通字符串:
#---------------------------------------------------------------------
echo "It is a test"

# 这里的双引号完全可以省略，以下命令与上面实例效果一致：
# echo It is a test



# 2.显示转义字符
#---------------------------------------------------------------------
echo "\"It is a test\""

# 结果将是:
# "It is a test"
# 同样，双引号也可以省略



# 3.显示变量
 
```
## printfc_output 
[`printfc_output`](./06_examples_output/printfc_output.sh)

```bash 
# \c	抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），
#		而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略
# \f	换页（formfeed）
# \n	换行
# \r	回车（Carriage return）
# \t	水平制表符
# \v	垂直制表符
# \\	一个字面上的反斜杠字符
# \ddd	表示1到3位数八进制值的字符。仅在格式字符串中有效
# \0ddd	表示1到3位的八进制值字符

# 实例
# -----------------------------------------------------------
printf "a string, no processing:<%s>\n" "A\nB"
#a string, no processing:<A\nB>

printf "a string, no processing:<%b>\n" "A\nB"
#a string, no processing:<A
#B>

printf "www.xxx.com \a"
#www.xxx.com $                  #不换行

printf "\n警告\a字符"
printf "\ngo back\b gogogo\n"
 
```
## printf_output 
[`printf_output`](./06_examples_output/printf_output.sh)

```bash 
# ---------------------------------------------------------------------------------
# printf 命令的语法：
# 		printf  format-string  [arguments...]
# 参数说明：
#		format-string: 为格式控制字符串
#		arguments: 为参数列表。
# ---------------------------------------------------------------------------------
# %d %s %c %f 格式替代符详解:

# d: Decimal 十进制整数 -- 对应位置参数必须是十进制整数，否则报错！
# s: String 字符串 -- 对应位置参数必须是字符串或者字符型，否则报错！
# c: Char 字符 -- 对应位置参数必须是字符串或者字符型，否则报错！
# f: Float 浮点 -- 对应位置参数必须是数字型，否则报错！
# ---------------------------------------------------------------------------------

# 如：其中最后一个参数是 "def"，%c 自动截取字符串的第一个字符作为结果输出。
printf "%d %s %c\n" 1 "abc" "def" # 1 abc d
# ---------------------------------------------------------------------------------



# 实例如下：
# ---------------------------------------------------------------------------------

echo "Hello, Shell"		# Hello, Shell

printf "Hello, Shell\n"		# Hello, Shell



# 接下来,我来用一个脚本来体现printf的强大功能：
# ---------------------------------------------------------------------------------

printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg  
printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234 
printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543 
printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876 


# 执行脚本，输出结果如下所示：
# ---------------------------------------------------------------------------------
 
```
# 07_examples_test 
[**07_examples_test**](./07_examples_test)
## test_file 
[`test_file`](./07_examples_test/test_file.sh)

```bash 
# ------------------------------------------------------------------------------
# -e 文件名		如果文件存在						则为真
# -r 文件名		如果文件存在且可读				则为真
# -w 文件名		如果文件存在且可写				则为真
# -x 文件名		如果文件存在且可执行				则为真
# -s 文件名		如果文件存在且不为空				则为真
# -d 文件名		如果文件存在且为目录				则为真
# -f 文件名		如果文件存在且为普通文件			则为真
# -c 文件名		如果文件存在且为字符型特殊文件 ASCII	则为真
# -b 文件名		如果文件存在且为块特殊文件二级制		则为真
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# 实例演示：
# ------------------------------------------------------------------------------

cd /bin
if test -e ./bash
then
    echo '文件已存在!'
else
    echo '文件不存在!'
fi


if test -r ./bash; then
	echo "文件可读"
else
	echo "文件不可读"
fi	

if test -w ./bash; then
	echo "文件可写"
else
	echo "文件不可写"
fi	

if test -x ./bash; then
	echo "文件可执行"
else
 
```
## test_math 
[`test_math`](./07_examples_test/test_math.sh)

```bash 
# 参数				说明
# ------------------------------------------------------------------------------
# -eq			等于			则为真
# -ne			不等于		则为真
# -gt			大于			则为真
# -ge			大于等于 		则为真
# -lt			小于			则为真
# -le			小于等于		则为真
# ------------------------------------------------------------------------------




# ------------------------------------------------------------------------------
#		实例演示：
# ------------------------------------------------------------------------------

num1=100
num2=100
if test $[num1] -eq $[num2]
then
    echo '两个数相等！'
else
    echo '两个数不相等！'
fi


if test $num1 -ne $num2; then
	echo 'num1 != num2'
else
    echo 'num1 == num2'
fi

num1=100
num2=101
if test $num1 -le $num2; then
	echo 'num1 <= num2'
else
    echo 'num1 > num2'
fi

 
```
## test_string 
[`test_string`](./07_examples_test/test_string.sh)

```bash 
# 参数					说明
# ------------------------------------------------------------------------------
# =				等于					则为真
# !=			不相等				则为真
# -z 字符串		字符串的长度为零		则为真
# -n 字符串		字符串的长度不为零	则为真
# ------------------------------------------------------------------------------



# ------------------------------------------------------------------------------
# 		实例演示：
# ------------------------------------------------------------------------------

num1="www"
num2="abc"

if test $num1 = $num2; then
    echo '两个字符串相等!'
else
    echo '两个字符串不相等!'
fi

if test $num1 != $num2; then
	echo "两个字符串不等"
fi	

str1=""
if test -z $str1; then
	echo "空字符串"
fi

if test -n $num2; then
	echo "非空字符串"
fi		

#	输出结果：
# ------------------------------------------------------------------------------
# 两个字符串不相等! 
```
# 08_examples_process 
[**08_examples_process**](./08_examples_process)
## each 
[`each`](./08_examples_process/each.sh)

```bash 
echo "-------::::WHILE循环输出 使用 let i++ 自增:::::---------"
j=0
while [ $j -lt ${#my_arry[@]} ]
do
  echo ${my_arry[$j]}
  let j++
done

echo "--------:::WHILE循环输出 使用 let  "n++ "自增: 多了双引号，其实不用也可以:::---------"
n=0
while [ $n -lt ${#my_arry[@]} ]
do
  echo ${my_arry[$n]}
  let "n++"
done

echo "---------::::WHILE循环输出 使用 let m+=1 自增,这种写法其他编程中也常用::::----------"
m=0
while [ $m -lt ${#my_arry[@]} ]
do
  echo ${my_arry[$m]}
  let m+=1
done

echo "-------::WHILE循环输出 使用 a=$[$a+1] 自增,个人觉得这种写法比较麻烦::::----------"
a=0
while [ $a -lt ${#my_arry[@]} ]
do
 echo ${my_arry[$a]}
 a=$[$a+1]
done

read status 
```
## process_case 
[`process_case`](./08_examples_process/process_case.sh)

```bash 

# case 值 in
# 模式1)
#    command1
#    command2
#    ...
#    commandN
#    ;;
# 模式2)
#    command1
#    command2
#    ...
#    commandN
#   ;;
# esac
# -----------------------------------------------------------------------------

# case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。
# 取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。

# 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。
# 如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。
# -----------------------------------------------------------------------------

# ----------------------------------------------------------------------
# 	esac
# ----------------------------------------------------------------------
# case的语法和Java family语言差别很大，
# 它需要一个esac（就是case反过来）作为结束标记，
# 每个case分支用右圆括号，用两个分号表示break。

# 下面的脚本提示输入1到4，与每一种模式进行匹配：
# -----------------------------------------------------------------------------

echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  
    	echo '你选择了 1'
    ;;
 
```
## process_for 
[`process_for`](./08_examples_process/process_for.sh)

```bash 


# for循环一般格式为：
# ----------------------------------------------------------------------
# for var in item1 item2 ... itemN
# do
#    command1
#    command2
#    ...
#    commandN
# done
# ----------------------------------------------------------------------
# for((assignment;condition:next));do
#    command_1;
#    command_2;
#    commond_..;
# done;
# ----------------------------------------------------------------------

# 写成一行：
# ----------------------------------------------------------------------
# for var in item1 item2 ... itemN; do command1; command2… done;

# 当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。
# 命令可为任何有效的shell命令和语句。
# 
# in列表可以包含替换、字符串和文件名。
# in列表是可选的，如果不用它，for循环使用命令行的位置参数。
# ----------------------------------------------------------------------




# 例如，顺序输出当前列表中的数字：
# ----------------------------------------------------------------------

for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done

 
```
## process_ifelse 
[`process_ifelse`](./08_examples_process/process_ifelse.sh)

```bash 
# ----------------------------------------------------------------------
# if 语句语法格式：
# ----------------------------------------------------------------------
# if condition
# then
#    command1 
#    command2
#    ...
#    commandN 
# fi
# ----------------------------------------------------------------------


# 写成一行（适用于终端命令提示符）：
# ----------------------------------------------------------------------

if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi  # 末尾的fi就是if倒过来拼写，后面还会遇到类似的。

# ----------------------------------------------------------------------
# 		if else
# ----------------------------------------------------------------------
# if else 语法格式：
# ----------------------------------------------------------------------
# if condition
# then
#    command1 
#    command2
#    ...
#    commandN
# else
#    command
# fi
# ----------------------------------------------------------------------


# ----------------------------------------------------------------------
#			if else-if else
# ----------------------------------------------------------------------
# if else-if else 语法格式：
# ----------------------------------------------------------------------

 
```
## process_loop_jump 
[`process_loop_jump`](./08_examples_process/process_loop_jump.sh)

```bash 
# 	break命令
# ----------------------------------------------------------------------
# break命令允许跳出所有循环（终止执行后面的所有循环）。


# 下面的例子中，脚本进入死循环直至用户输入数字大于5。
# 要跳出这个循环，返回到shell提示符下，需要使用break命令。

while :
do
    echo -n "输入 1 到 5 之间的数字:"
    read aNum
    case $aNum in
        1|2|3|4|5) 
        	echo "你输入的数字为 $aNum!"
        ;;
        *) 
        	echo "你输入的数字不是 1 到 5 之间的! 游戏结束"
            break
        ;;
    esac
done


# 执行以上代码，输出结果为：
# ----------------------------------------------------------------------

# 输入 1 到 5 之间的数字:3
# 你输入的数字为 3!
# 输入 1 到 5 之间的数字:7
# 你输入的数字不是 1 到 5 之间的! 游戏结束



# ----------------------------------------------------------------------
#	continue
# ----------------------------------------------------------------------
# continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。

# 对上面的例子进行修改：

 
```
## process_select 
[`process_select`](./08_examples_process/process_select.sh)

```bash 


# ----------------------------------------------------------------------
# 示例1：选择你的操作系统。
#	一次选择后，break 跳出循环
# ----------------------------------------------------------------------
echo "What is your favourite OS?"
select var in "Linux" "Gnu Hurd" "Free BSD" "Other"; do
  break
done

echo "You have selected $var"





# ----------------------------------------------------------------------
# 示例2：RANDOM 随机数
# ----------------------------------------------------------------------
pocket=()

select var in 跳跳糖 糖 很多糖 企鹅糖; do
  echo "除了 $var 还要什么吗？"
  echo "RANDOM: $RANDOM"
  if ((RANDOM%4 == 0)); then
    echo "呀！时间不够了，快上车！"
    break 
  fi
  
  pocket+=("$var")
done

echo "你最后说的那个 $var 弄丢了……"

# IFS 是内部域分隔符，设置变量 pocket的分隔符
IFS='、'
echo "现在口袋里只有：${pocket[*]}。"

# 设置回原来的值
IFS=$' \t\n'
 
```
## process_unlimit_loop 
[`process_unlimit_loop`](./08_examples_process/process_unlimit_loop.sh)

```bash 

# 无限循环语法格式：

# while :
# do
#    command
# done

num=0

function test1() {
	while :
	do
		num=`expr $num + 1`
		echo "循环 ${num}"
		if ((num >= 10)); then
			sleep 10
		fi		
	done	
}

# 或者

# while true
# do
#    command
# done

function test2() {
	while true; do
		num=`expr $num + 1`
		echo "循环 ${num}"
		if ((num >= 10)); then
			sleep 10
		fi
	done	
}

# 或者
# for (( ; ; ))

 
```
## process_until 
[`process_until`](./08_examples_process/process_until.sh)

```bash 


# ----------------------------------------------------------------------
# until 语法格式:

# until condition
# do
#    command
# done

# condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。
# ----------------------------------------------------------------------

# 以下实例我们使用 until 命令来输出 0 ~ 9 的数字：
# ----------------------------------------------------------------------

a=0

until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done


# 运行结果：
#
# 0
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9

read a 
```
## process_while 
[`process_while`](./08_examples_process/process_while.sh)

```bash 
# while condition
# do
#    command
# done
# ----------------------------------------------------------------------





# 以下是一个基本的while循环，测试条件是：
#	如果int小于等于5，那么条件返回真。
#	int从0开始，每次循环处理时，int加1。
# 运行上述脚本，返回数字1到5，然后终止。
# ----------------------------------------------------------------------

int=1
while(( $int<=5 ))
do
    echo $int
    let "int++"
done


# 运行脚本，输出：
# ----------------------------------------------------------------------
# 1
# 2
# 3
# 4
# 5


# 代码中使用了 Bash let 命令，它用于执行一个或多个表达式，
#	变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令
# ----------------------------------------------------------------------
a=1
b=3
c=-1
let "c=a+b"
echo "c: $c"
 
```
# 09_examples_function 
[**09_examples_function**](./09_examples_function)
## func_param 
[`func_param`](./09_examples_function/func_param.sh)

```bash 
# 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。
# -----------------------------------------------------------------------

# 另外，还有几个特殊字符用来处理参数：
# -----------------------------------------------------------------------
# 参数处理		说明
# -----------------------------------------------------------------------
# $#		传递到脚本的参数个数
# $*		以一个单字符串显示所有向脚本传递的参数
# $$		脚本运行的当前进程ID号
# $!		后台运行的最后一个进程的ID号
# $@		与$*相同，但是使用时加引号，并在引号中返回每个参数。
# $-		显示Shell使用的当前选项，与set命令功能相同。
# $?		显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
# -----------------------------------------------------------------------


# 带参数的函数示例：
# -----------------------------------------------------------------------

funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73

# 输出结果：

# 第一个参数为 1 !
# 第二个参数为 2 !
# 第十个参数为 10 !
# 第十个参数为 34 !
# 第十一个参数为 73 !
# 参数总数有 11 个!
# 作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !
# -----------------------------------------------------------------------
 
```
## func_started 
[`func_started`](./09_examples_function/func_started.sh)

```bash 

# [ function ] funname [()]
# {
#    action;
#    [return int;]
# }
# ----------------------------------------------------------------------

# 说明：

# 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
# 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255
# ----------------------------------------------------------------------


# 下面的例子定义了一个函数并进行调用：
# ----------------------------------------------------------------------

demoFun(){
    echo "这是我的第一个 shell 函数!"
}

echo "-----函数开始执行-----"
demoFun
echo "-----函数执行完毕-----"

#		输出结果：
# ----------------------------------------------------------------------

# -----函数开始执行-----
# 这是我的第一个 shell 函数!
# -----函数执行完毕-----





# 下面定义一个带有return语句的函数：
# ----------------------------------------------------------------------

funWithReturn(){
 
```
# 10_examples_file 
[**10_examples_file**](./10_examples_file)
## file_dev_null 
[`file_dev_null`](./10_examples_file/file_dev_null.sh)

```bash 
$ command > /dev/null

# /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。
# 但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。
# ----------------------------------------------------------------------



# ----------------------------------------------------------------------
# 如果希望屏蔽 stdout 和 stderr，可以这样写：
$ command > /dev/null 2>&1

# 注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。
# ---------------------------------------------------------------------- 
```
## file_eof 
[`file_eof`](./10_examples_file/file_eof.sh)

```bash 
# command << delimiter
#     document
# delimiter
# ----------------------------------------------------------------------
# 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。
# ----------------------------------------------------------------------

# 注意：
# ----------------------------------------------------------------------
# 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。
# 开始的delimiter前后的空格会被忽略掉。
# ----------------------------------------------------------------------




# ----------------------------------------------------------------------
# 实例
# ----------------------------------------------------------------------
# 在命令行中通过 wc -l 命令计算 Here Document 的行数：

wc -l << EOF
    welcome
    bash 
    world
EOF


# 3          # 输出结果为 3 行
# ----------------------------------------------------------------------





# ----------------------------------------------------------------------
# 我们也可以将 Here Document 用在脚本中，例如：
# ----------------------------------------------------------------------

# test.sh

 
```
## file_help 
[`file_help`](./10_examples_file/file_help.sh)

```bash 



# ----------------------------------------------------------------------
# 实例
# ----------------------------------------------------------------------
function help() {
cat << HELP
USAGE: help function test [-h] "file_help.sh 1 2"
OPTIONS: -h help text
EXAMPLE: xtitlebar "cvs"
HELP
exit 0
}

# in case of error or if -h is given we call the function help:
if [[ $1 == '' || $1 == '-h' ]]; then
  help
fi

# send the escape sequence to change the xterm titelbar:
echo -e "\033]0;$1\007" 
```
## file_stdin 
[`file_stdin`](./10_examples_file/file_stdin.sh)

```bash 
#
# 注意：输出重定向是大于号(>)，输入重定向是小于号(<)。
# ----------------------------------------------------------------------




# 	实例
# ----------------------------------------------------------------------
# 接着以上实例，我们需要统计 users 文件的行数，执行以下命令：
$ wc -l users
# 2 users

# 也可以将输入重定向到 users 文件：
$  wc -l < users
# 2 

# 注意：上面两个例子的结果不同：
#	第一个例子，会输出文件名；
#	第二个不会，因为它仅仅知道从标准输入读取内容。
# ----------------------------------------------------------------------



# command1 < infile > outfile
# 同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。
# ----------------------------------------------------------------------
$ wc -l < users > stats
# tips：wc -l 统计 users内容行数，把结果写入到文件stats




# ----------------------------------------------------------------------
# 如果希望 stderr 重定向到 file，可以这样写：
# $ command 2 > file

#如果希望 stderr 追加到 file 文件末尾，可以这样写：
# $ command 2 >> file

#2 表示标准错误文件(stderr)。
 
```
## file_stdout 
[`file_stdout`](./10_examples_file/file_stdout.sh)

```bash 

# 重定向命令列表如下：
# ----------------------------------------------------------------------

# 命令					说明
# ----------------------------------------------------------------------
# command > file	将输出重定向到 file。
# command < file	将输入重定向到 file。
# command >> file	将输出以追加的方式重定向到 file。
# n > file			将文件描述符为 n 的文件重定向到 file。
# n >> file			将文件描述符为 n 的文件以追加的方式重定向到 file。
# n >& m			将输出文件 m 和 n 合并。
# n <& m			将输入文件 m 和 n 合并。
# << tag			将开始标记 tag 和结束标记 tag 之间的内容作为输入。
# ----------------------------------------------------------------------


# ----------------------------------------------------------------------
# 需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。
# ----------------------------------------------------------------------
# 重定向深入讲解
# ----------------------------------------------------------------------
# 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：

# 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。
# 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。
# 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。
# 默认情况下，command > file 将 stdout 重定向到 file，command < file 将stdin 重定向到 file。
# ----------------------------------------------------------------------




# 					输出重定向
# ----------------------------------------------------------------------
# 重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:

# command1 > file1
# 上面这个命令执行command1然后将输出的内容存入file1。

# 注意：任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用>>操作符。
 
```
# 11_examples_import 
[**11_examples_import**](./11_examples_import)
## import_file 
[`import_file`](./11_examples_import/import_file.sh)

```bash 
# . filename   
# 注意点号(.)和文件名中间有一空格

# 或
# source filename
# ---------------------------------------------------------------------------



#	实例
# ---------------------------------------------------------------------------

# 创建两个 shell 脚本文件。

# test1.sh 代码如下：
# url="http://www.baidu.com"


# test2.sh 代码如下：

#使用  “.” 号来引用 test1.sh 文件
. ./test1.sh

# 或者使用以下包含文件代码
# source ./test1.sh

echo "官网地址：$url"

# 接下来，我们为 test2.sh 添加可执行权限并执行：
#$ chmod +x test2.sh 
#$ ./test2.sh 

#官网地址：http://www.runoob.com
#注：被包含的文件 test1.sh 不需要可执行权限。

read exits 
```
## test1 
[`test1`](./11_examples_import/test1.sh)

```bash 
 
```
# 12_examples_debug 
[**12_examples_debug**](./12_examples_debug)
## shell_debug 
[`shell_debug`](./12_examples_debug/shell_debug.sh)

```bash 
# 启用
set -euo pipefail
trap "echo 'error: Script failed: see failed command above'" ERR

# 禁用
set +euo

# ==============================================================================
#		shell —— debug 脚本调试
# ==============================================================================
# -n 将会只检查脚本的语法错误而不执行脚本。 
# -v 将会在命令执行前输出它们。
# -x 将会在命令行处理之后输出命令。
#
# bash -n scriptname
# bash -v scriptname
# bash -x scriptname
#-------------------------------------------------------------------------------
# set -euo pipefail
# trap "echo 'error: Script failed: see failed command above'" ERR
# 一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息
#
# -u			如果有任何未定义的变量引用，该设置将导致脚本立即退出
# -e			如果任何命令[1]具有非零退出状态，该选项将指示bash立即退出
# -o pipefail	此设置可防止管道中的错误被屏蔽。
#				如果管道中的任何命令失败，则将使用该返回码作为整个管道的返回码 (echo $?)。
#				默认情况下，管道的返回代码是最后一个命令的代码 - 即使成功。
# ------------------------------------------------------------------------------




# =================================================================
#	 示例1：检查脚本的语法错误
# =================================================================
bash -n debug.sh

# output:
#-------------------------------------------------------------------
# 

 
```
# 13_examples_settings 
[**13_examples_settings**](./13_examples_settings)
## ifs_test 
[`ifs_test`](./13_examples_settings/ifs_test.sh)

```bash 


# =================================================================
#	 示例：如果将此调用为 
#	sh ifs_test.sh notes todo-list 'My Resume.doc'，
# 	然后使用默认的IFS值，则第三个参数将被错误解析为两个单独的文件名为“My”和“Resume.doc”。
#	当实际上它是一个文件，它有一个空间，名为“我的Resume.doc”。
#-------------------------------------------------------------------
# 	将IFS设置为$'\n\t'意味着单词拆分只会发生在换行符和制表符中。
# 	IFS=$'\n\t'
# =================================================================
IFS=$'\n\t'
for arg in $@; do
    echo "doing something with file: $arg"
done

#-------------------------------------------------------------------
# output:
#-------------------------------------------------------------------
# $ ./ifs_test.sh notes todo-list 'My Resume.doc'
# doing something with file: notes
# doing something with file: todo-list
# doing something with file: My
# doing something with file: Resume.doc


#-------------------------------------------------------------------
# IFS=$'\n\t' 
#	output:
#-------------------------------------------------------------------
# $ ./ifs_test.sh notes todo-list 'My Resume.doc'
# doing something with file: notes
# doing something with file: todo-list
# doing something with file: My Resume.doc

 
```
## settings_ifs 
[`settings_ifs`](./13_examples_settings/settings_ifs.sh)

```bash 
# =================================================================
#	设置IFS —— 设置分词的方式
# =================================================================
# 设置默认是分词分割规则
# -----------------------------------------------------------------




# =================================================================
#	 示例：使用空格分词，items被分割成3个词
# =================================================================
IFS=$' '
items="a b c"
for x in $items; do
    echo "$x"
done


# output:
#-------------------------------------------------------------------
# a
# b
# c



# =================================================================
#	 示例：使用换行分词，items被认为是一个单词
# =================================================================
IFS=$'\n'
items="a b c"
for y in $items; do
    echo "$y"
done

# output:
#-------------------------------------------------------------------
# a b c


 
```
# 14_examples_commons 
[**14_examples_commons**](./14_examples_commons)
## check-args 
[`check-args`](./14_examples_commons/check-args.sh)

```bash 
# =================================================================
# 在严格模式下，您需要将此用于所有位置参数引用
# =================================================================

set -u

name=${1:-}
if [[ -z "$name" ]]; then
    echo "usage: $0 NAME"
    exit 1
fi


echo "Hello, $name"


#-------------------------------------------------------------------
# output:
#-------------------------------------------------------------------
# $ bash check-args.sh
# usage: check-args.sh NAME

# $ bash check-args.sh haha
# Hello, haha
 
```
## force-clean 
[`force-clean`](./14_examples_commons/force-clean.sh)

```bash 
# =================================================================
#	clean —— 在脚本退出的时候强制清理资源
# =================================================================
# 定义了一个执行清理或释放资源的bash函数，然后在退出时注册要自动调用的函数。
# -----------------------------------------------------------------




# =================================================================
#	 示例：以下是如何使用退出时来强大地清理临时目录：
# =================================================================
# 现在脚本可以在“$scratch”目录中写入文件。
# 退出时会自动删除，无论是否出错，或正常完成。

# 生成一个临时目录
scratch=$(mktemp -d -t tmp.XXXXXXXXXX)
function finish {
  rm -rf "$scratch"
}

trap finish EXIT

# output:
#-------------------------------------------------------------------
# 
```
## strong-bash 
[`strong-bash`](./14_examples_commons/strong-bash.sh)

```bash 
# =================================================================
#		强壮健康的bash脚本应该是怎么样的？
# =================================================================
# 1、提供--help标记
# 2、检查所有命令的可用性
# 3、独立于当前工作目录
# 4、如何读取输入：环境变量 vs. 标记
# 5、打印对系统执行的所有操作
# 6、如果有必要，提供--silent选项
# 7、重新开启显示
# 8、用动画的方式显示进度
# 9、用颜色编码输出
# 10、出现错误立即退出脚本
# 11、自己执行清理工作
# 12、在退出时使用不同的错误码
# 13、在结束时打印一个新行
# -----------------------------------------------------------------


set -euo pipefail

# =================================================================
#	 示例：提供 --help 标记
# -----------------------------------------------------------------
# 提供help选项，为脚本提供帮助文档，也方便在日后使用或修改文本作为依据
# =================================================================
function help() {
	if [[ ${#@} -ne 0  && "${@#"--help"}" = "" ]]; then
	  printf -- "${0} --help\n"
	  printf -- '强壮的bash脚本...\n'
	  printf -- "usage: bash +x ${0}\n"
	  exit 0
	fi
}

# output:
#-------------------------------------------------------------------
# $ sh strong-bash.sh --help
# strong-bash.sh --help
# 强壮的bash脚本...
# usage: bash +x strong-bash.sh 
 
```
#  
[****](./)
## comment 
[`comment`](.//comment.sh)

```bash 
# =================================================================
#
# =================================================================
#
# -----------------------------------------------------------------




# =================================================================
#	 示例：
# =================================================================

# output:
#------------------------------------------------------------------
# 


# =================================================================
#	 示例：
# =================================================================


# output:
#-------------------------------------------------------------------
#







read exits 
```
