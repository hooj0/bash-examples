#!/bin/bash
# author:   hoojo
# email:    hoojo_@126.com
# github:   https://github.com/hooj0
# create: 	2018-07-01
# copyright by hoojo@2018
# @changelog Add What should be a strong and healthy bash script? List 13 scripting requirements


# =================================================================
#		强壮健康的bash脚本应该是怎么样的？
# =================================================================
# 1、提供--help标记
# 2、检查所有命令的可用性
# 3、独立于当前工作目录
# 4、如何读取输入：环境变量 vs. 标记
# 5、打印对系统执行的所有操作
# 6、如果有必要，提供--silent选项
# 7、重新开启显示
# 8、用动画的方式显示进度
# 9、用颜色编码输出
# 10、出现错误立即退出脚本
# 11、自己执行清理工作
# 12、在退出时使用不同的错误码
# 13、在结束时打印一个新行
# -----------------------------------------------------------------


set -euo pipefail

# =================================================================
#	 示例：提供 --help 标记
# -----------------------------------------------------------------
# 提供help选项，为脚本提供帮助文档，也方便在日后使用或修改文本作为依据
# =================================================================
function help() {
	if [[ ${#@} -ne 0  && "${@#"--help"}" = "" ]]; then
	  printf -- "${0} --help\n"
	  printf -- '强壮的bash脚本...\n'
	  printf -- "usage: bash +x ${0}\n"
	  exit 0
	fi
}

# output:
#-------------------------------------------------------------------
# $ sh strong-bash.sh --help
# strong-bash.sh --help
# 强壮的bash脚本...
# usage: bash +x strong-bash.sh 


# =================================================================
#	 示例：检查所有命令的可用性
# -----------------------------------------------------------------
# 检查命令的可用性，在不可用的情况下，给予友好提示
# =================================================================
function checkCmd() {
	count=`command -v dockerd | wc -l`
	echo "count: ${count}"
	#_=$(command -v dockerd)
	#if [ $? != 0 ]; then
	if [ $(command -v dockerd) ]; then
	  printf -- "You don\'t seem to have Docker installed.\n"
	  printf -- 'Get it: https://www.docker.com/community-edition\n'
	  printf -- 'Exiting with code 127\n'
	  exit 127
	fi
}


# output:
#-------------------------------------------------------------------
#



# ==================================================================
#	 示例：独立于当前工作目录
#-------------------------------------------------------------------
# 提供独立的工作目录，能让脚本在任何地方运行，在脚本中坚持使用“绝对路径”
# ==================================================================
# 可以使用dirname $0引用脚本的当前路径：
function workdir() {
	CURR_DIR="$(dirname $0)";
	printf -- 'moving web-app.jar to /opt/app.jar';
	mv "${CURR_DIR}/web-app.jar" /opt/app.jar;
}


# output:
#-------------------------------------------------------------------
#



# =================================================================
#	 示例：如何读取输入：环境变量 vs. 标记
#------------------------------------------------------------------
# 脚本接收参数的方式有3种，环境变量、选项标记、动态输入(read)
# 根据经验，对于不影响脚本行为的值，可以使用环境变量，
#	而对于可能触发脚本不同流程的值，可以使用脚本参数。
#
# 如果参数较多，可以将固定的参数从环境变量读取，变化频繁的使用参数读取
# =================================================================

# 不影响脚本行为的变量可能是访问令牌和 ID、路径等配置
#-------------------------------------------------------------------
export ACCESS_TOKEN='xxxxxxxxxxxx'
# 运行脚本读取 变量 ${ACCESS_TOKEN}
# ./xxx.sh 

# 或者 通过临时变量的形式
# INSTANCE_COUNT=400 ASYNC=true ./xxx.sh


# 对于业务流程上的参数，通过标记的形式读取
#-------------------------------------------------------------------
# ./xxx.sh --async --instance-count 400

# 或者 动态变量参数
# ./xxx.sh --async true --token 'xxxxxxxxxxx'



# output:
#-------------------------------------------------------------------
#



# =================================================================
#	 示例：打印对系统执行的所有操作，输出操作日志
#-------------------------------------------------------------------
# 脚本通常会对系统执行有状态的更改。不过，由于我们不知道用户何时会向发送SIGINT，
# 也不知道脚本错误何时可能导致脚本意外终止，因此很有必要将正在做的事情打印在终端上，
# 这样用户就可以在不去查看脚本的情况下回溯这些步骤
#------------------------------------------------------------------
# 对于没有输出日志的脚本可以试试以下方式运行：
# 		将会在命令执行前输出它们
# 		bash -v xxx.sh  
# 		将会在命令行处理之后输出命令
# 		bash -x xxx.sh
# =================================================================
function printLog() {
	printf -- 'Downloading required document to ./downloaded... '
	wget -o ./downloaded https://some.site.com/downloaded
	
	printf -- 'Moving ./downloaded to /opt/downloaded...'
	mv ./downloaded /opt/
	
	printf -- 'Creating symlink to /opt/downloaded...'
	ln -s /opt/downloaded /usr/bin/downloaded
}


# output:
#-------------------------------------------------------------------
#



# =================================================================
#	 示例：在必要时提供 --silent 选项
#-------------------------------------------------------------------
# 有些脚本是为了将其输出传给其他脚本。虽说脚本都应该能够单独运行，
# 不过有时候也有必要让它们把输出结果传给另一个脚本。
# 可以利用stty -echo来实现--silent标记：
# =================================================================
function silentOption() {
	if [ ${#@} -ne 0 ] && [ "${@#"--silent"}" = "" ]; then
	  stty -echo;
	fi;
	
	# ...
	# before point of intended output:
	stty +echo && printf -- 'intended output\n';
	
	# silence it again till end of script
	stty -echo;
	# ...
	stty +echo;
	exit 0;
}

# output:
#-------------------------------------------------------------------
#



# =================================================================
#	 示例：重新开启显示
#------------------------------------------------------------------
# 在使用stty -echo关闭脚本显示之后，如果发生致命错误，脚本将终止，
# 而且不会恢复终端输出，这样对用户来说是没有意义的。
# 可以使用trap来捕捉SIGINT和其他操作系统级别的信号，
# 然后使用stty echo打开终端显示：
# =================================================================
error_handle() {
  stty echo;
}

function openEcho() {
	if [ ${#@} -ne 0 ] && [ "${@#"--silent"}" = "" ]; then
	  stty -echo;
	  trap error_handle INT;
	  trap error_handle TERM;
	  trap error_handle KILL;
	  trap error_handle EXIT;
	fi;
}


# output:
#------------------------------------------------------------------
#



# =================================================================
#	 示例：用动画的方式显示进度
#------------------------------------------------------------------
# 有些命令需要运行很长时间，并非所有脚本都提供了进度条。
# 在用户等待异步任务完成时，可以通过一些方式告诉他们脚本仍在运行。
# 比如在while循环中打印一些信息：
# http://mywiki.wooledge.org/BashFAQ/034
# =================================================================
function process() {
	printf -- 'Performing asynchronous action..'
	#./trigger-action.sh
	
	DONE=0;
	while [ $DONE -eq 0 ]; do
	  #./async-checker.sh
	  # 如果上面的脚本执行完毕，就跳出死循环
	  if [ "$?" = "0" ]; then DONE=1; fi;
	  # 输出一个 点号，进度在持续推进	
	  printf -- '.'
	  sleep 1
	done;
	printf -- ' DONE!\n'
}


# output:
#------------------------------------------------------------------
#


# =================================================================
#	 示例：用颜色编码输出
# 在脚本中调用其他二进制文件或脚本时，对它们的输出进行颜色编码，
# 这样就可以知道哪个输出来自哪个脚本或二进制文件，查找日志就更加方便。
#------------------------------------------------------------------
# 理想情况下，脚本应该输出白色（默认的，前台进程），
# 子进程应该使用灰色（通常不需要，除非出现错误），
# 使用绿色表示成功，红色表示失败，黄色表示警告。
# 颜色对照表：https://misc.flogisoft.com/bash/tip_colors_and_formatting
# =================================================================
function colorLog() {
	printf -- 'doing something... \n';
	printf -- '\033[37m 子进程应该使用灰色 \033[0m\n';
	printf -- '\033[32m SUCCESS: yay \033[0m\n';
	printf -- '\033[33m WARNING: hmm \033[0m\n';
	printf -- '\033[31m ERROR: fubar \033[0m\n';
	
	echo -e "Normal \e[1m这是加粗的输出！"
	echo -e "\e[1;31;42m Yes it is awful \e[0m"
}

colorLog
# output:
#------------------------------------------------------------------
#




# =================================================================
#	 示例：出现错误立即退出脚本
# set -e表示从当前位置开始，如果出现任何错误都将触发EXIT。
# 相反，set +e表示不管出现任何错误继续执行脚本。
#
# 如果脚本是有状态的（每个后续步骤都依赖前一个步骤），那么请使用set -e，
# 在脚本出现错误时立即退出脚本。如果要求所有命令都要执行完（很少会这样），那么就使用set +e。
# =================================================================
function exitNow() {
	# 不依赖之前的脚本状态
	set +e;
	./script-1;
	./script-2; # does not depend on ./script-1
	./script-3; # does not depend on ./script-2
	
	# 依赖之前的脚本状态，前面的失败就立即退出
	set -e;
	./script-4;
	./script-5; # depends on success of ./script-4
	# ...
}

# output:
#------------------------------------------------------------------
#




# =================================================================
#	 示例：自己执行清理工作
# 大多数脚本在出现错误时不会执行清理工作，能够做好这方面工作的脚本实属罕见，
# 但这样做其实很有用，还可以省下不少时间。
# 前面已经给出过示例，让stty恢复正常，并借助trap命令来执行清理工作
# =================================================================
handle_exit_code() {
  ERROR_CODE="$?";
  printf -- "an error occurred. cleaning up now... ";
  # ... cleanup code ...
  printf -- "DONE.\nExiting with error code ${ERROR_CODE}.\n";
  exit ${ERROR_CODE};
}
	
function clean() {
	
	# 退出执行清理方法 handle_exit_code
	trap "handle_exit_code" EXIT;
	# ... actual script...
}

# output:
#------------------------------------------------------------------
#



# =================================================================
#	 示例：在退出时使用不同的错误码
# 在绝大多数 shell 脚本中，exit 0 表示执行成功，exit 1 表示发生错误。
# 对错误与错误码进行一对一的映射，这样有助于脚本调试。
#
# 这样做有另一个额外的好处，就是其他脚本在调用你的脚本时，可以根据错误码来判断发生了什么错误。
# =================================================================
function exitStatus() {
	if [ "$?" != "0" ]; then
	  printf -- 'X happened. Exiting with status code 1.\n';
	  exit 1;
	fi;
	
	# ...
	if [ "$?" != "0" ]; then
	  printf -- 'Y happened. Exiting with status code 2.\n';
	  exit 2;
	fi;
}

# output:
#------------------------------------------------------------------
#



# =================================================================
#	 示例：在结束时打印一个新行
# 如果你有在遵循脚本的最佳实践，那么可能会使用printf代替echo（它在不同系统中的行为有所差别）。
# 问题是printf在命令结束后不会自动添加一个新行.
# =================================================================
function wrap() {
	printf -- '\n';
	exit 0;
}

# output:
#------------------------------------------------------------------
#



echo "\e[1m Done!"
exit 0